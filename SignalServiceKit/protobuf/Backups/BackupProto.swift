//
// Copyright 2024 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only
//

// Code generated by Wire protocol buffer compiler, do not edit.
// Source: BackupProto.BackupProto in Backup.proto
import Foundation
import Wire

public struct BackupProto {

    public var unknownFields: UnknownFields = .init()

    public init() {
    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto : Hashable {
}
#endif

extension BackupProto : Sendable {
}

extension BackupProto : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto {
        BackupProto()
    }
}

extension BackupProto : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto"
    }

}

extension BackupProto : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto : Codable {

    public enum CodingKeys : CodingKey {
    }

}
#endif

/**
 * Subtypes within BackupProto
 */
extension BackupProto {

    public struct BackupInfo {

        public var version: UInt64
        public var backupTimeMs: UInt64
        public var unknownFields: UnknownFields = .init()

        public init(version: UInt64, backupTimeMs: UInt64) {
            self.version = version
            self.backupTimeMs = backupTimeMs
        }

    }

    public struct Frame {

        public var item: BackupProto.Frame.Item?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct AccountData {

        public var profileKey: Foundation.Data
        @ProtoDefaulted
        public var username: String?
        public var usernameLink: BackupProto.AccountData.UsernameLink?
        public var givenName: String
        public var familyName: String
        public var avatarUrlPath: String
        public var subscriberId: Foundation.Data
        public var subscriberCurrencyCode: String
        public var subscriptionManuallyCancelled: Bool
        public var accountSettings: BackupProto.AccountData.AccountSettings?
        public var unknownFields: UnknownFields = .init()

        public init(
            profileKey: Foundation.Data,
            givenName: String,
            familyName: String,
            avatarUrlPath: String,
            subscriberId: Foundation.Data,
            subscriberCurrencyCode: String,
            subscriptionManuallyCancelled: Bool,
            configure: (inout Self) -> Swift.Void = { _ in }
        ) {
            self.profileKey = profileKey
            self.givenName = givenName
            self.familyName = familyName
            self.avatarUrlPath = avatarUrlPath
            self.subscriberId = subscriberId
            self.subscriberCurrencyCode = subscriberCurrencyCode
            self.subscriptionManuallyCancelled = subscriptionManuallyCancelled
            configure(&self)
        }

    }

    public struct Recipient {

        /**
         * generated id for reference only within this file
         */
        public var id: UInt64
        public var destination: BackupProto.Recipient.Destination?
        public var unknownFields: UnknownFields = .init()

        public init(id: UInt64, configure: (inout Self) -> Swift.Void = { _ in }) {
            self.id = id
            configure(&self)
        }

    }

    public struct Contact {

        /**
         * should be 16 bytes
         */
        @ProtoDefaulted
        public var aci: Foundation.Data?
        /**
         * should be 16 bytes
         */
        @ProtoDefaulted
        public var pni: Foundation.Data?
        @ProtoDefaulted
        public var username: String?
        @ProtoDefaulted
        public var e164: UInt64?
        public var blocked: Bool
        public var hidden: Bool
        @ProtoDefaulted
        public var registered: BackupProto.Contact.Registered?
        public var unregisteredTimestamp: UInt64
        @ProtoDefaulted
        public var profileKey: Foundation.Data?
        public var profileSharing: Bool
        @ProtoDefaulted
        public var profileGivenName: String?
        @ProtoDefaulted
        public var profileFamilyName: String?
        public var hideStory: Bool
        public var unknownFields: UnknownFields = .init()

        public init(
            blocked: Bool,
            hidden: Bool,
            unregisteredTimestamp: UInt64,
            profileSharing: Bool,
            hideStory: Bool,
            configure: (inout Self) -> Swift.Void = { _ in }
        ) {
            self.blocked = blocked
            self.hidden = hidden
            self.unregisteredTimestamp = unregisteredTimestamp
            self.profileSharing = profileSharing
            self.hideStory = hideStory
            configure(&self)
        }

    }

    public struct Group {

        public var masterKey: Foundation.Data
        public var whitelisted: Bool
        public var hideStory: Bool
        @ProtoDefaulted
        public var storySendMode: BackupProto.Group.StorySendMode?
        public var snapshot: BackupProto.Group.GroupSnapshot?
        public var unknownFields: UnknownFields = .init()

        public init(
            masterKey: Foundation.Data,
            whitelisted: Bool,
            hideStory: Bool,
            configure: (inout Self) -> Swift.Void = { _ in }
        ) {
            self.masterKey = masterKey
            self.whitelisted = whitelisted
            self.hideStory = hideStory
            configure(&self)
        }

    }

    public struct SelfRecipient {

        public var unknownFields: UnknownFields = .init()

        public init() {
        }

    }

    public struct ReleaseNotes {

        public var unknownFields: UnknownFields = .init()

        public init() {
        }

    }

    public struct Chat {

        /**
         * generated id for reference only within this file
         */
        public var id: UInt64
        public var recipientId: UInt64
        public var archived: Bool
        /**
         * 0 = unpinned, otherwise chat is considered pinned and will be displayed in ascending order
         */
        public var pinnedOrder: UInt32
        /**
         * 0 = no expire timer.
         */
        public var expirationTimerMs: UInt64
        public var muteUntilMs: UInt64
        public var markedUnread: Bool
        public var dontNotifyForMentionsIfMuted: Bool
        @ProtoDefaulted
        public var wallpaper: BackupProto.FilePointer?
        public var unknownFields: UnknownFields = .init()

        public init(
            id: UInt64,
            recipientId: UInt64,
            archived: Bool,
            pinnedOrder: UInt32,
            expirationTimerMs: UInt64,
            muteUntilMs: UInt64,
            markedUnread: Bool,
            dontNotifyForMentionsIfMuted: Bool,
            configure: (inout Self) -> Swift.Void = { _ in }
        ) {
            self.id = id
            self.recipientId = recipientId
            self.archived = archived
            self.pinnedOrder = pinnedOrder
            self.expirationTimerMs = expirationTimerMs
            self.muteUntilMs = muteUntilMs
            self.markedUnread = markedUnread
            self.dontNotifyForMentionsIfMuted = dontNotifyForMentionsIfMuted
            configure(&self)
        }

    }

    public struct DistributionList {

        public var name: String
        /**
         * distribution list ids are uuids
         */
        public var distributionId: Foundation.Data
        public var allowReplies: Bool
        public var deletionTimestamp: UInt64
        @ProtoDefaulted
        public var privacyMode: BackupProto.DistributionList.PrivacyMode?
        /**
         * generated recipient id
         */
        public var memberRecipientIds: [UInt64] = []
        public var unknownFields: UnknownFields = .init()

        public init(
            name: String,
            distributionId: Foundation.Data,
            allowReplies: Bool,
            deletionTimestamp: UInt64,
            configure: (inout Self) -> Swift.Void = { _ in }
        ) {
            self.name = name
            self.distributionId = distributionId
            self.allowReplies = allowReplies
            self.deletionTimestamp = deletionTimestamp
            configure(&self)
        }

    }

    public struct Identity {

        public var serviceId: Foundation.Data
        public var identityKey: Foundation.Data
        public var timestamp: UInt64
        public var firstUse: Bool
        public var verified: Bool
        public var nonblockingApproval: Bool
        public var unknownFields: UnknownFields = .init()

        public init(
            serviceId: Foundation.Data,
            identityKey: Foundation.Data,
            timestamp: UInt64,
            firstUse: Bool,
            verified: Bool,
            nonblockingApproval: Bool
        ) {
            self.serviceId = serviceId
            self.identityKey = identityKey
            self.timestamp = timestamp
            self.firstUse = firstUse
            self.verified = verified
            self.nonblockingApproval = nonblockingApproval
        }

    }

    public struct Call {

        public var callId: UInt64
        public var conversationRecipientId: UInt64
        @ProtoDefaulted
        public var type: BackupProto.Call.Type_?
        public var outgoing: Bool
        public var timestamp: UInt64
        @ProtoDefaulted
        public var ringerRecipientId: UInt64?
        @ProtoDefaulted
        public var event: BackupProto.Call.Event?
        public var unknownFields: UnknownFields = .init()

        public init(
            callId: UInt64,
            conversationRecipientId: UInt64,
            outgoing: Bool,
            timestamp: UInt64,
            configure: (inout Self) -> Swift.Void = { _ in }
        ) {
            self.callId = callId
            self.conversationRecipientId = conversationRecipientId
            self.outgoing = outgoing
            self.timestamp = timestamp
            configure(&self)
        }

    }

    public struct ChatItem {

        /**
         * conversation id
         */
        public var chatId: UInt64
        /**
         * recipient id
         */
        public var authorId: UInt64
        public var dateSent: UInt64
        /**
         * timestamp of when expiration timer started ticking down
         */
        @ProtoDefaulted
        public var expireStartDate: UInt64?
        /**
         * how long timer of message is (ms)
         */
        @ProtoDefaulted
        public var expiresInMs: UInt64?
        /**
         * ordered from oldest to newest
         */
        public var revisions: [BackupProto.ChatItem] = []
        public var sms: Bool
        public var directionalDetails: BackupProto.ChatItem.DirectionalDetails?
        public var item: BackupProto.ChatItem.Item?
        public var unknownFields: UnknownFields = .init()

        public init(
            chatId: UInt64,
            authorId: UInt64,
            dateSent: UInt64,
            sms: Bool,
            configure: (inout Self) -> Swift.Void = { _ in }
        ) {
            self.chatId = chatId
            self.authorId = authorId
            self.dateSent = dateSent
            self.sms = sms
            configure(&self)
        }

    }

    public struct SendStatus {

        public var recipientId: UInt64
        @ProtoDefaulted
        public var deliveryStatus: BackupProto.SendStatus.Status?
        public var networkFailure: Bool
        public var identityKeyMismatch: Bool
        public var sealedSender: Bool
        /**
         * the time the status was last updated -- if from a receipt, it should be the sentTime of the receipt
         */
        public var lastStatusUpdateTimestamp: UInt64
        public var unknownFields: UnknownFields = .init()

        public init(
            recipientId: UInt64,
            networkFailure: Bool,
            identityKeyMismatch: Bool,
            sealedSender: Bool,
            lastStatusUpdateTimestamp: UInt64,
            configure: (inout Self) -> Swift.Void = { _ in }
        ) {
            self.recipientId = recipientId
            self.networkFailure = networkFailure
            self.identityKeyMismatch = identityKeyMismatch
            self.sealedSender = sealedSender
            self.lastStatusUpdateTimestamp = lastStatusUpdateTimestamp
            configure(&self)
        }

    }

    public struct Text {

        public var body: String
        public var bodyRanges: [BackupProto.BodyRange] = []
        public var unknownFields: UnknownFields = .init()

        public init(body: String, configure: (inout Self) -> Swift.Void = { _ in }) {
            self.body = body
            configure(&self)
        }

    }

    public struct StandardMessage {

        public var quote: BackupProto.Quote?
        public var text: BackupProto.Text?
        public var attachments: [BackupProto.FilePointer] = []
        public var linkPreview: [BackupProto.LinkPreview] = []
        @ProtoDefaulted
        public var longText: BackupProto.FilePointer?
        public var reactions: [BackupProto.Reaction] = []
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct ContactMessage {

        public var contact: [BackupProto.ContactAttachment] = []
        public var reactions: [BackupProto.Reaction] = []
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct ContactAttachment {

        @ProtoDefaulted
        public var name: BackupProto.ContactAttachment.Name?
        public var number: [BackupProto.ContactAttachment.Phone] = []
        public var email: [BackupProto.ContactAttachment.Email] = []
        public var address: [BackupProto.ContactAttachment.PostalAddress] = []
        @ProtoDefaulted
        public var avatar: BackupProto.ContactAttachment.Avatar?
        @ProtoDefaulted
        public var organization: String?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct DocumentMessage {

        public var text: BackupProto.Text?
        @ProtoDefaulted
        public var document: BackupProto.FilePointer?
        public var reactions: [BackupProto.Reaction] = []
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct VoiceMessage {

        public var quote: BackupProto.Quote?
        @ProtoDefaulted
        public var audio: BackupProto.FilePointer?
        public var reactions: [BackupProto.Reaction] = []
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct StickerMessage {

        public var sticker: BackupProto.Sticker?
        public var reactions: [BackupProto.Reaction] = []
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    /**
     * Tombstone for remote delete
     */
    public struct RemoteDeletedMessage {

        public var unknownFields: UnknownFields = .init()

        public init() {
        }

    }

    public struct Sticker {

        public var packId: Foundation.Data
        public var packKey: Foundation.Data
        public var stickerId: UInt32
        @ProtoDefaulted
        public var emoji: String?
        public var unknownFields: UnknownFields = .init()

        public init(
            packId: Foundation.Data,
            packKey: Foundation.Data,
            stickerId: UInt32,
            configure: (inout Self) -> Swift.Void = { _ in }
        ) {
            self.packId = packId
            self.packKey = packKey
            self.stickerId = stickerId
            configure(&self)
        }

    }

    public struct LinkPreview {

        public var url: String
        @ProtoDefaulted
        public var title: String?
        @ProtoDefaulted
        public var image: BackupProto.FilePointer?
        @ProtoDefaulted
        public var description_: String?
        @ProtoDefaulted
        public var date: UInt64?
        public var unknownFields: UnknownFields = .init()

        public init(url: String, configure: (inout Self) -> Swift.Void = { _ in }) {
            self.url = url
            configure(&self)
        }

    }

    public struct FilePointer {

        @ProtoDefaulted
        public var key: Foundation.Data?
        @ProtoDefaulted
        public var contentType: String?
        /**
         * Size of fullsize decrypted media blob in bytes.
         * Can be ignored if unset/unavailable.
         */
        @ProtoDefaulted
        public var size: UInt32?
        @ProtoDefaulted
        public var incrementalMac: Foundation.Data?
        @ProtoDefaulted
        public var incrementalMacChunkSize: Foundation.Data?
        @ProtoDefaulted
        public var fileName: String?
        @ProtoDefaulted
        public var flags: UInt32?
        @ProtoDefaulted
        public var width: UInt32?
        @ProtoDefaulted
        public var height: UInt32?
        @ProtoDefaulted
        public var caption: String?
        @ProtoDefaulted
        public var blurHash: String?
        public var locator: BackupProto.FilePointer.Locator?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct Quote {

        /**
         * null if the target message could not be found at time of quote insert
         */
        @ProtoDefaulted
        public var targetSentTimestamp: UInt64?
        public var authorId: UInt64
        @ProtoDefaulted
        public var text: String?
        public var attachments: [BackupProto.Quote.QuotedAttachment] = []
        public var bodyRanges: [BackupProto.BodyRange] = []
        @ProtoDefaulted
        public var type: BackupProto.Quote.Type_?
        public var unknownFields: UnknownFields = .init()

        public init(authorId: UInt64, configure: (inout Self) -> Swift.Void = { _ in }) {
            self.authorId = authorId
            configure(&self)
        }

    }

    public struct BodyRange {

        @ProtoDefaulted
        public var start: UInt32?
        @ProtoDefaulted
        public var length: UInt32?
        public var associatedValue: BackupProto.BodyRange.AssociatedValue?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct Reaction {

        public var emoji: String
        public var authorId: UInt64
        public var sentTimestamp: UInt64
        @ProtoDefaulted
        public var receivedTimestamp: UInt64?
        /**
         * A higher sort order means that a reaction is more recent
         */
        public var sortOrder: UInt64
        public var unknownFields: UnknownFields = .init()

        public init(
            emoji: String,
            authorId: UInt64,
            sentTimestamp: UInt64,
            sortOrder: UInt64,
            configure: (inout Self) -> Swift.Void = { _ in }
        ) {
            self.emoji = emoji
            self.authorId = authorId
            self.sentTimestamp = sentTimestamp
            self.sortOrder = sortOrder
            configure(&self)
        }

    }

    public struct ChatUpdateMessage {

        public var update: BackupProto.ChatUpdateMessage.Update?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct CallChatUpdate {

        public var call: BackupProto.CallChatUpdate.Call?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct IndividualCallChatUpdate {

        public var unknownFields: UnknownFields = .init()

        public init() {
        }

    }

    public struct GroupCallChatUpdate {

        @ProtoDefaulted
        public var startedCallAci: Foundation.Data?
        public var startedCallTimestamp: UInt64
        public var inCallAcis: [Foundation.Data] = []
        public var unknownFields: UnknownFields = .init()

        public init(startedCallTimestamp: UInt64, configure: (inout Self) -> Swift.Void = { _ in }) {
            self.startedCallTimestamp = startedCallTimestamp
            configure(&self)
        }

    }

    public struct SimpleChatUpdate {

        @ProtoDefaulted
        public var type: BackupProto.SimpleChatUpdate.Type_?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct GroupDescriptionChatUpdate {

        public var newDescription: String
        public var unknownFields: UnknownFields = .init()

        public init(newDescription: String) {
            self.newDescription = newDescription
        }

    }

    /**
     * For 1:1 chat updates only.
     * For group thread updates use GroupExpirationTimerUpdate.
     */
    public struct ExpirationTimerChatUpdate {

        /**
         * 0 means the expiration timer was disabled
         */
        public var expiresInMs: UInt32
        public var unknownFields: UnknownFields = .init()

        public init(expiresInMs: UInt32) {
            self.expiresInMs = expiresInMs
        }

    }

    public struct ProfileChangeChatUpdate {

        public var previousName: String
        public var newName: String
        public var unknownFields: UnknownFields = .init()

        public init(previousName: String, newName: String) {
            self.previousName = previousName
            self.newName = newName
        }

    }

    public struct ThreadMergeChatUpdate {

        public var previousE164: UInt64
        public var unknownFields: UnknownFields = .init()

        public init(previousE164: UInt64) {
            self.previousE164 = previousE164
        }

    }

    public struct SessionSwitchoverChatUpdate {

        public var e164: UInt64
        public var unknownFields: UnknownFields = .init()

        public init(e164: UInt64) {
            self.e164 = e164
        }

    }

    public struct GroupChangeChatUpdate {

        /**
         * Must be one or more; all updates batched together came from
         * a single batched group state update.
         */
        public var updates: [BackupProto.GroupChangeChatUpdate.Update] = []
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct GenericGroupUpdate {

        @ProtoDefaulted
        public var updaterAci: Foundation.Data?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct GroupCreationUpdate {

        @ProtoDefaulted
        public var updaterAci: Foundation.Data?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct GroupNameUpdate {

        @ProtoDefaulted
        public var updaterAci: Foundation.Data?
        /**
         * Null value means the group name was removed.
         */
        @ProtoDefaulted
        public var newGroupName: String?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct GroupAvatarUpdate {

        @ProtoDefaulted
        public var updaterAci: Foundation.Data?
        public var wasRemoved: Bool
        public var unknownFields: UnknownFields = .init()

        public init(wasRemoved: Bool, configure: (inout Self) -> Swift.Void = { _ in }) {
            self.wasRemoved = wasRemoved
            configure(&self)
        }

    }

    public struct GroupDescriptionUpdate {

        @ProtoDefaulted
        public var updaterAci: Foundation.Data?
        /**
         * Null value means the group description was removed.
         */
        @ProtoDefaulted
        public var newDescription: String?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public enum GroupV2AccessLevel : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN = 0
        case ANY = 1
        case MEMBER = 2
        case ADMINISTRATOR = 3
        case UNSATISFIABLE = 4

        public static var defaultedValue: BackupProto.GroupV2AccessLevel {
            BackupProto.GroupV2AccessLevel.UNKNOWN
        }
        public var description: String {
            switch self {
            case .UNKNOWN: return "UNKNOWN"
            case .ANY: return "ANY"
            case .MEMBER: return "MEMBER"
            case .ADMINISTRATOR: return "ADMINISTRATOR"
            case .UNSATISFIABLE: return "UNSATISFIABLE"
            }
        }

    }

    public struct GroupMembershipAccessLevelChangeUpdate {

        @ProtoDefaulted
        public var updaterAci: Foundation.Data?
        @ProtoDefaulted
        public var accessLevel: BackupProto.GroupV2AccessLevel?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct GroupAttributesAccessLevelChangeUpdate {

        @ProtoDefaulted
        public var updaterAci: Foundation.Data?
        @ProtoDefaulted
        public var accessLevel: BackupProto.GroupV2AccessLevel?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct GroupAnnouncementOnlyChangeUpdate {

        @ProtoDefaulted
        public var updaterAci: Foundation.Data?
        public var isAnnouncementOnly: Bool
        public var unknownFields: UnknownFields = .init()

        public init(isAnnouncementOnly: Bool, configure: (inout Self) -> Swift.Void = { _ in }) {
            self.isAnnouncementOnly = isAnnouncementOnly
            configure(&self)
        }

    }

    public struct GroupAdminStatusUpdate {

        @ProtoDefaulted
        public var updaterAci: Foundation.Data?
        /**
         * The aci who had admin status granted or revoked.
         */
        public var memberAci: Foundation.Data
        public var wasAdminStatusGranted: Bool
        public var unknownFields: UnknownFields = .init()

        public init(
            memberAci: Foundation.Data,
            wasAdminStatusGranted: Bool,
            configure: (inout Self) -> Swift.Void = { _ in }
        ) {
            self.memberAci = memberAci
            self.wasAdminStatusGranted = wasAdminStatusGranted
            configure(&self)
        }

    }

    public struct GroupMemberLeftUpdate {

        public var aci: Foundation.Data
        public var unknownFields: UnknownFields = .init()

        public init(aci: Foundation.Data) {
            self.aci = aci
        }

    }

    public struct GroupMemberRemovedUpdate {

        @ProtoDefaulted
        public var removerAci: Foundation.Data?
        public var removedAci: Foundation.Data
        public var unknownFields: UnknownFields = .init()

        public init(removedAci: Foundation.Data, configure: (inout Self) -> Swift.Void = { _ in }) {
            self.removedAci = removedAci
            configure(&self)
        }

    }

    public struct SelfInvitedToGroupUpdate {

        @ProtoDefaulted
        public var inviterAci: Foundation.Data?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct SelfInvitedOtherUserToGroupUpdate {

        /**
         * If no invitee id available, use GroupUnknownInviteeUpdate
         */
        public var inviteeServiceId: Foundation.Data
        public var unknownFields: UnknownFields = .init()

        public init(inviteeServiceId: Foundation.Data) {
            self.inviteeServiceId = inviteeServiceId
        }

    }

    public struct GroupUnknownInviteeUpdate {

        /**
         * Can be the self user.
         */
        @ProtoDefaulted
        public var inviterAci: Foundation.Data?
        public var inviteeCount: UInt32
        public var unknownFields: UnknownFields = .init()

        public init(inviteeCount: UInt32, configure: (inout Self) -> Swift.Void = { _ in }) {
            self.inviteeCount = inviteeCount
            configure(&self)
        }

    }

    public struct GroupInvitationAcceptedUpdate {

        @ProtoDefaulted
        public var inviterAci: Foundation.Data?
        public var newMemberAci: Foundation.Data
        public var unknownFields: UnknownFields = .init()

        public init(newMemberAci: Foundation.Data, configure: (inout Self) -> Swift.Void = { _ in }) {
            self.newMemberAci = newMemberAci
            configure(&self)
        }

    }

    public struct GroupInvitationDeclinedUpdate {

        @ProtoDefaulted
        public var inviterAci: Foundation.Data?
        /**
         * Note: if invited by pni, just set inviteeAci to nil.
         */
        @ProtoDefaulted
        public var inviteeAci: Foundation.Data?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct GroupMemberJoinedUpdate {

        public var newMemberAci: Foundation.Data
        public var unknownFields: UnknownFields = .init()

        public init(newMemberAci: Foundation.Data) {
            self.newMemberAci = newMemberAci
        }

    }

    public struct GroupMemberAddedUpdate {

        @ProtoDefaulted
        public var updaterAci: Foundation.Data?
        public var newMemberAci: Foundation.Data
        public var hadOpenInvitation: Bool
        /**
         * If hadOpenInvitation is true, optionally include aci of the inviter.
         */
        @ProtoDefaulted
        public var inviterAci: Foundation.Data?
        public var unknownFields: UnknownFields = .init()

        public init(
            newMemberAci: Foundation.Data,
            hadOpenInvitation: Bool,
            configure: (inout Self) -> Swift.Void = { _ in }
        ) {
            self.newMemberAci = newMemberAci
            self.hadOpenInvitation = hadOpenInvitation
            configure(&self)
        }

    }

    /**
     * An invitation to self was revoked.
     */
    public struct GroupSelfInvitationRevokedUpdate {

        @ProtoDefaulted
        public var revokerAci: Foundation.Data?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    /**
     * These invitees should never be the local user.
     * Use GroupSelfInvitationRevokedUpdate in those cases.
     * The inviter or updater can be the local user.
     */
    public struct GroupInvitationRevokedUpdate {

        /**
         * The member that revoked the invite(s), not the inviter!
         * Assumed to be an admin (at the time, may no longer be an
         * admin or even a member).
         */
        @ProtoDefaulted
        public var updaterAci: Foundation.Data?
        public var invitees: [BackupProto.GroupInvitationRevokedUpdate.Invitee] = []
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct GroupJoinRequestUpdate {

        public var requestorAci: Foundation.Data
        public var unknownFields: UnknownFields = .init()

        public init(requestorAci: Foundation.Data) {
            self.requestorAci = requestorAci
        }

    }

    public struct GroupJoinRequestApprovalUpdate {

        public var requestorAci: Foundation.Data
        /**
         * The aci that approved or rejected the request.
         */
        @ProtoDefaulted
        public var updaterAci: Foundation.Data?
        public var wasApproved: Bool
        public var unknownFields: UnknownFields = .init()

        public init(
            requestorAci: Foundation.Data,
            wasApproved: Bool,
            configure: (inout Self) -> Swift.Void = { _ in }
        ) {
            self.requestorAci = requestorAci
            self.wasApproved = wasApproved
            configure(&self)
        }

    }

    public struct GroupJoinRequestCanceledUpdate {

        public var requestorAci: Foundation.Data
        public var unknownFields: UnknownFields = .init()

        public init(requestorAci: Foundation.Data) {
            self.requestorAci = requestorAci
        }

    }

    /**
     * A single requestor has requested to join and cancelled
     * their request repeatedly with no other updates in between.
     * The last action encompassed by this update is always a
     * cancellation; if there was another open request immediately
     * after, it will be a separate GroupJoinRequestUpdate, either
     * in the same frame or in a subsequent frame.
     */
    public struct GroupSequenceOfRequestsAndCancelsUpdate {

        public var requestorAci: Foundation.Data
        public var count: UInt32
        public var unknownFields: UnknownFields = .init()

        public init(requestorAci: Foundation.Data, count: UInt32) {
            self.requestorAci = requestorAci
            self.count = count
        }

    }

    public struct GroupInviteLinkResetUpdate {

        @ProtoDefaulted
        public var updaterAci: Foundation.Data?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct GroupInviteLinkEnabledUpdate {

        @ProtoDefaulted
        public var updaterAci: Foundation.Data?
        public var linkRequiresAdminApproval: Bool
        public var unknownFields: UnknownFields = .init()

        public init(linkRequiresAdminApproval: Bool, configure: (inout Self) -> Swift.Void = { _ in }) {
            self.linkRequiresAdminApproval = linkRequiresAdminApproval
            configure(&self)
        }

    }

    public struct GroupInviteLinkAdminApprovalUpdate {

        @ProtoDefaulted
        public var updaterAci: Foundation.Data?
        public var linkRequiresAdminApproval: Bool
        public var unknownFields: UnknownFields = .init()

        public init(linkRequiresAdminApproval: Bool, configure: (inout Self) -> Swift.Void = { _ in }) {
            self.linkRequiresAdminApproval = linkRequiresAdminApproval
            configure(&self)
        }

    }

    public struct GroupInviteLinkDisabledUpdate {

        @ProtoDefaulted
        public var updaterAci: Foundation.Data?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct GroupMemberJoinedByLinkUpdate {

        public var newMemberAci: Foundation.Data
        public var unknownFields: UnknownFields = .init()

        public init(newMemberAci: Foundation.Data) {
            self.newMemberAci = newMemberAci
        }

    }

    /**
     * A gv1->gv2 migration occurred.
     */
    public struct GroupV2MigrationUpdate {

        public var unknownFields: UnknownFields = .init()

        public init() {
        }

    }

    /**
     * Another user migrated gv1->gv2 but was unable to add
     * the local user and invited them instead.
     */
    public struct GroupV2MigrationSelfInvitedUpdate {

        public var unknownFields: UnknownFields = .init()

        public init() {
        }

    }

    /**
     * The local user migrated gv1->gv2 but was unable to
     * add some members and invited them instead.
     * (Happens if we don't have the invitee's profile key)
     */
    public struct GroupV2MigrationInvitedMembersUpdate {

        public var invitedMembersCount: UInt32
        public var unknownFields: UnknownFields = .init()

        public init(invitedMembersCount: UInt32) {
            self.invitedMembersCount = invitedMembersCount
        }

    }

    /**
     * The local user migrated gv1->gv2 but was unable to
     * add or invite some members and dropped them instead.
     * (Happens for e164 members where we don't have an aci).
     */
    public struct GroupV2MigrationDroppedMembersUpdate {

        public var droppedMembersCount: UInt32
        public var unknownFields: UnknownFields = .init()

        public init(droppedMembersCount: UInt32) {
            self.droppedMembersCount = droppedMembersCount
        }

    }

    /**
     * For 1:1 timer updates, use ExpirationTimerChatUpdate.
     */
    public struct GroupExpirationTimerUpdate {

        /**
         * 0 means the expiration timer was disabled.
         */
        public var expiresInMs: UInt32
        @ProtoDefaulted
        public var updaterAci: Foundation.Data?
        public var unknownFields: UnknownFields = .init()

        public init(expiresInMs: UInt32, configure: (inout Self) -> Swift.Void = { _ in }) {
            self.expiresInMs = expiresInMs
            configure(&self)
        }

    }

    public struct StickerPack {

        public var id: Foundation.Data
        public var key: Foundation.Data
        public var title: String
        public var author: String
        /**
         * First one should be cover sticker.
         */
        public var stickers: [BackupProto.StickerPackSticker] = []
        public var unknownFields: UnknownFields = .init()

        public init(
            id: Foundation.Data,
            key: Foundation.Data,
            title: String,
            author: String,
            configure: (inout Self) -> Swift.Void = { _ in }
        ) {
            self.id = id
            self.key = key
            self.title = title
            self.author = author
            configure(&self)
        }

    }

    public struct StickerPackSticker {

        @ProtoDefaulted
        public var data: BackupProto.FilePointer?
        public var emoji: String
        public var unknownFields: UnknownFields = .init()

        public init(emoji: String, configure: (inout Self) -> Swift.Void = { _ in }) {
            self.emoji = emoji
            configure(&self)
        }

    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.BackupInfo : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.BackupInfo : Hashable {
}
#endif

extension BackupProto.BackupInfo : Sendable {
}

extension BackupProto.BackupInfo : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.BackupInfo"
    }

}

extension BackupProto.BackupInfo : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var version: UInt64 = 0
        var backupTimeMs: UInt64 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: version = try protoReader.decode(UInt64.self)
            case 2: backupTimeMs = try protoReader.decode(UInt64.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.version = version
        self.backupTimeMs = backupTimeMs
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.version)
        try protoWriter.encode(tag: 2, value: self.backupTimeMs)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.BackupInfo : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.version = try container.decode(stringEncoded: UInt64.self, forKey: "version")
        self.backupTimeMs = try container.decode(stringEncoded: UInt64.self, forKey: "backupTimeMs")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || self.version != 0 {
            try container.encode(stringEncoded: self.version, forKey: "version")
        }
        if includeDefaults || self.backupTimeMs != 0 {
            try container.encode(stringEncoded: self.backupTimeMs, forKey: "backupTimeMs")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Frame : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Frame : Hashable {
}
#endif

extension BackupProto.Frame : Sendable {
}

extension BackupProto.Frame : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.Frame {
        BackupProto.Frame()
    }
}

extension BackupProto.Frame : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.Frame"
    }

}

extension BackupProto.Frame : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var item: BackupProto.Frame.Item? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: item = .account(try protoReader.decode(BackupProto.AccountData.self))
            case 2: item = .recipient(try protoReader.decode(BackupProto.Recipient.self))
            case 3: item = .chat(try protoReader.decode(BackupProto.Chat.self))
            case 4: item = .chatItem(try protoReader.decode(BackupProto.ChatItem.self))
            case 5: item = .call(try protoReader.decode(BackupProto.Call.self))
            case 6: item = .stickerPack(try protoReader.decode(BackupProto.StickerPack.self))
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.item = item
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        if let item = self.item {
            try item.encode(to: protoWriter)
        }
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.Frame : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        if let account = try container.decodeIfPresent(BackupProto.AccountData.self, forKey: "account") {
            self.item = .account(account)
        } else if let recipient = try container.decodeIfPresent(BackupProto.Recipient.self, forKey: "recipient") {
            self.item = .recipient(recipient)
        } else if let chat = try container.decodeIfPresent(BackupProto.Chat.self, forKey: "chat") {
            self.item = .chat(chat)
        } else if let chatItem = try container.decodeIfPresent(BackupProto.ChatItem.self, forKey: "chatItem") {
            self.item = .chatItem(chatItem)
        } else if let call = try container.decodeIfPresent(BackupProto.Call.self, forKey: "call") {
            self.item = .call(call)
        } else if let stickerPack = try container.decodeIfPresent(BackupProto.StickerPack.self, forKey: "stickerPack") {
            self.item = .stickerPack(stickerPack)
        } else {
            self.item = nil
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        switch self.item {
        case .account(let account): try container.encode(account, forKey: "account")
        case .recipient(let recipient): try container.encode(recipient, forKey: "recipient")
        case .chat(let chat): try container.encode(chat, forKey: "chat")
        case .chatItem(let chatItem): try container.encode(chatItem, forKey: "chatItem")
        case .call(let call): try container.encode(call, forKey: "call")
        case .stickerPack(let stickerPack): try container.encode(stickerPack, forKey: "stickerPack")
        case Optional.none: break
        }
    }

}
#endif

/**
 * Subtypes within BackupProto.Frame
 */
extension BackupProto.Frame {

    public enum Item {

        case account(BackupProto.AccountData)
        case recipient(BackupProto.Recipient)
        case chat(BackupProto.Chat)
        case chatItem(BackupProto.ChatItem)
        case call(BackupProto.Call)
        case stickerPack(BackupProto.StickerPack)

        fileprivate func encode(to protoWriter: ProtoWriter) throws {
            switch self {
            case .account(let account): try protoWriter.encode(tag: 1, value: account)
            case .recipient(let recipient): try protoWriter.encode(tag: 2, value: recipient)
            case .chat(let chat): try protoWriter.encode(tag: 3, value: chat)
            case .chatItem(let chatItem): try protoWriter.encode(tag: 4, value: chatItem)
            case .call(let call): try protoWriter.encode(tag: 5, value: call)
            case .stickerPack(let stickerPack): try protoWriter.encode(tag: 6, value: stickerPack)
            }
        }

    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Frame.Item : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Frame.Item : Hashable {
}
#endif

extension BackupProto.Frame.Item : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.AccountData : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.AccountData : Hashable {
}
#endif

extension BackupProto.AccountData : Sendable {
}

extension BackupProto.AccountData : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.AccountData"
    }

}

extension BackupProto.AccountData : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var profileKey: Foundation.Data = .init()
        var username: String? = nil
        var usernameLink: BackupProto.AccountData.UsernameLink? = nil
        var givenName: String = ""
        var familyName: String = ""
        var avatarUrlPath: String = ""
        var subscriberId: Foundation.Data = .init()
        var subscriberCurrencyCode: String = ""
        var subscriptionManuallyCancelled: Bool = false
        var accountSettings: BackupProto.AccountData.AccountSettings? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: profileKey = try protoReader.decode(Foundation.Data.self)
            case 2: username = try protoReader.decode(String.self)
            case 3: usernameLink = try protoReader.decode(BackupProto.AccountData.UsernameLink.self)
            case 4: givenName = try protoReader.decode(String.self)
            case 5: familyName = try protoReader.decode(String.self)
            case 6: avatarUrlPath = try protoReader.decode(String.self)
            case 7: subscriberId = try protoReader.decode(Foundation.Data.self)
            case 8: subscriberCurrencyCode = try protoReader.decode(String.self)
            case 9: subscriptionManuallyCancelled = try protoReader.decode(Bool.self)
            case 10: accountSettings = try protoReader.decode(BackupProto.AccountData.AccountSettings.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.profileKey = profileKey
        self._username.wrappedValue = username
        self.usernameLink = usernameLink
        self.givenName = givenName
        self.familyName = familyName
        self.avatarUrlPath = avatarUrlPath
        self.subscriberId = subscriberId
        self.subscriberCurrencyCode = subscriberCurrencyCode
        self.subscriptionManuallyCancelled = subscriptionManuallyCancelled
        self.accountSettings = accountSettings
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.profileKey)
        try protoWriter.encode(tag: 2, value: self.username)
        try protoWriter.encode(tag: 3, value: self.usernameLink)
        try protoWriter.encode(tag: 4, value: self.givenName)
        try protoWriter.encode(tag: 5, value: self.familyName)
        try protoWriter.encode(tag: 6, value: self.avatarUrlPath)
        try protoWriter.encode(tag: 7, value: self.subscriberId)
        try protoWriter.encode(tag: 8, value: self.subscriberCurrencyCode)
        try protoWriter.encode(tag: 9, value: self.subscriptionManuallyCancelled)
        try protoWriter.encode(tag: 10, value: self.accountSettings)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.AccountData : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.profileKey = try container.decode(stringEncoded: Foundation.Data.self, forKey: "profileKey")
        self._username.wrappedValue = try container.decodeIfPresent(String.self, forKey: "username")
        self.usernameLink = try container.decodeIfPresent(BackupProto.AccountData.UsernameLink.self, forKey: "usernameLink")
        self.givenName = try container.decode(String.self, forKey: "givenName")
        self.familyName = try container.decode(String.self, forKey: "familyName")
        self.avatarUrlPath = try container.decode(String.self, forKey: "avatarUrlPath")
        self.subscriberId = try container.decode(stringEncoded: Foundation.Data.self, forKey: "subscriberId")
        self.subscriberCurrencyCode = try container.decode(String.self, forKey: "subscriberCurrencyCode")
        self.subscriptionManuallyCancelled = try container.decode(Bool.self, forKey: "subscriptionManuallyCancelled")
        self.accountSettings = try container.decodeIfPresent(BackupProto.AccountData.AccountSettings.self, forKey: "accountSettings")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.profileKey.isEmpty {
            try container.encode(stringEncoded: self.profileKey, forKey: "profileKey")
        }
        try container.encodeIfPresent(self.username, forKey: "username")
        try container.encodeIfPresent(self.usernameLink, forKey: "usernameLink")
        if includeDefaults || !self.givenName.isEmpty {
            try container.encode(self.givenName, forKey: "givenName")
        }
        if includeDefaults || !self.familyName.isEmpty {
            try container.encode(self.familyName, forKey: "familyName")
        }
        if includeDefaults || !self.avatarUrlPath.isEmpty {
            try container.encode(self.avatarUrlPath, forKey: "avatarUrlPath")
        }
        if includeDefaults || !self.subscriberId.isEmpty {
            try container.encode(stringEncoded: self.subscriberId, forKey: "subscriberId")
        }
        if includeDefaults || !self.subscriberCurrencyCode.isEmpty {
            try container.encode(self.subscriberCurrencyCode, forKey: "subscriberCurrencyCode")
        }
        if includeDefaults || self.subscriptionManuallyCancelled != false {
            try container.encode(self.subscriptionManuallyCancelled, forKey: "subscriptionManuallyCancelled")
        }
        try container.encodeIfPresent(self.accountSettings, forKey: "accountSettings")
    }

}
#endif

/**
 * Subtypes within BackupProto.AccountData
 */
extension BackupProto.AccountData {

    public enum PhoneNumberSharingMode : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN = 0
        case EVERYBODY = 1
        case NOBODY = 2

        public static var defaultedValue: BackupProto.AccountData.PhoneNumberSharingMode {
            BackupProto.AccountData.PhoneNumberSharingMode.UNKNOWN
        }
        public var description: String {
            switch self {
            case .UNKNOWN: return "UNKNOWN"
            case .EVERYBODY: return "EVERYBODY"
            case .NOBODY: return "NOBODY"
            }
        }

    }

    public struct UsernameLink {

        /**
         * 32 bytes of entropy used for encryption
         */
        public var entropy: Foundation.Data
        /**
         * 16 bytes of encoded UUID provided by the server
         */
        public var serverId: Foundation.Data
        @ProtoDefaulted
        public var color: BackupProto.AccountData.UsernameLink.Color?
        public var unknownFields: UnknownFields = .init()

        public init(
            entropy: Foundation.Data,
            serverId: Foundation.Data,
            configure: (inout Self) -> Swift.Void = { _ in }
        ) {
            self.entropy = entropy
            self.serverId = serverId
            configure(&self)
        }

    }

    @dynamicMemberLookup
    public struct AccountSettings {

        @CopyOnWrite
        private var storage: BackupProto.AccountData.AccountSettings.Storage
        /**
         * Access the underlying storage
         */
        public subscript<Property>(dynamicMember keyPath: WritableKeyPath<BackupProto.AccountData.AccountSettings.Storage, Property>) -> Property {
            get {
                storage[keyPath: keyPath]
            }
            set {
                storage[keyPath: keyPath] = newValue
            }
        }
        public var readReceipts: Bool {
            get {
                storage.readReceipts
            }
            set {
                storage.readReceipts = newValue
            }
        }
        public var sealedSenderIndicators: Bool {
            get {
                storage.sealedSenderIndicators
            }
            set {
                storage.sealedSenderIndicators = newValue
            }
        }
        public var typingIndicators: Bool {
            get {
                storage.typingIndicators
            }
            set {
                storage.typingIndicators = newValue
            }
        }
        public var linkPreviews: Bool {
            get {
                storage.linkPreviews
            }
            set {
                storage.linkPreviews = newValue
            }
        }
        public var notDiscoverableByPhoneNumber: Bool {
            get {
                storage.notDiscoverableByPhoneNumber
            }
            set {
                storage.notDiscoverableByPhoneNumber = newValue
            }
        }
        public var preferContactAvatars: Bool {
            get {
                storage.preferContactAvatars
            }
            set {
                storage.preferContactAvatars = newValue
            }
        }
        /**
         * 0 means no universal expire timer.
         */
        public var universalExpireTimer: UInt32 {
            get {
                storage.universalExpireTimer
            }
            set {
                storage.universalExpireTimer = newValue
            }
        }
        public var preferredReactionEmoji: [String] {
            get {
                storage.preferredReactionEmoji
            }
            set {
                storage.preferredReactionEmoji = newValue
            }
        }
        public var displayBadgesOnProfile: Bool {
            get {
                storage.displayBadgesOnProfile
            }
            set {
                storage.displayBadgesOnProfile = newValue
            }
        }
        public var keepMutedChatsArchived: Bool {
            get {
                storage.keepMutedChatsArchived
            }
            set {
                storage.keepMutedChatsArchived = newValue
            }
        }
        public var hasSetMyStoriesPrivacy: Bool {
            get {
                storage.hasSetMyStoriesPrivacy
            }
            set {
                storage.hasSetMyStoriesPrivacy = newValue
            }
        }
        public var hasViewedOnboardingStory: Bool {
            get {
                storage.hasViewedOnboardingStory
            }
            set {
                storage.hasViewedOnboardingStory = newValue
            }
        }
        public var storiesDisabled: Bool {
            get {
                storage.storiesDisabled
            }
            set {
                storage.storiesDisabled = newValue
            }
        }
        public var storyViewReceiptsEnabled: Bool? {
            get {
                storage.storyViewReceiptsEnabled
            }
            set {
                storage.storyViewReceiptsEnabled = newValue
            }
        }
        public var hasSeenGroupStoryEducationSheet: Bool {
            get {
                storage.hasSeenGroupStoryEducationSheet
            }
            set {
                storage.hasSeenGroupStoryEducationSheet = newValue
            }
        }
        public var hasCompletedUsernameOnboarding: Bool {
            get {
                storage.hasCompletedUsernameOnboarding
            }
            set {
                storage.hasCompletedUsernameOnboarding = newValue
            }
        }
        public var phoneNumberSharingMode: BackupProto.AccountData.PhoneNumberSharingMode? {
            get {
                storage.phoneNumberSharingMode
            }
            set {
                storage.phoneNumberSharingMode = newValue
            }
        }
        public var unknownFields: UnknownFields {
            get {
                storage.unknownFields
            }
            set {
                storage.unknownFields = newValue
            }
        }

        public init(
            readReceipts: Bool,
            sealedSenderIndicators: Bool,
            typingIndicators: Bool,
            linkPreviews: Bool,
            notDiscoverableByPhoneNumber: Bool,
            preferContactAvatars: Bool,
            universalExpireTimer: UInt32,
            displayBadgesOnProfile: Bool,
            keepMutedChatsArchived: Bool,
            hasSetMyStoriesPrivacy: Bool,
            hasViewedOnboardingStory: Bool,
            storiesDisabled: Bool,
            hasSeenGroupStoryEducationSheet: Bool,
            hasCompletedUsernameOnboarding: Bool,
            configure: (inout Self.Storage) -> Swift.Void = { _ in }
        ) {
            self.storage = BackupProto.AccountData.AccountSettings.Storage(
                    readReceipts: readReceipts,
                    sealedSenderIndicators: sealedSenderIndicators,
                    typingIndicators: typingIndicators,
                    linkPreviews: linkPreviews,
                    notDiscoverableByPhoneNumber: notDiscoverableByPhoneNumber,
                    preferContactAvatars: preferContactAvatars,
                    universalExpireTimer: universalExpireTimer,
                    displayBadgesOnProfile: displayBadgesOnProfile,
                    keepMutedChatsArchived: keepMutedChatsArchived,
                    hasSetMyStoriesPrivacy: hasSetMyStoriesPrivacy,
                    hasViewedOnboardingStory: hasViewedOnboardingStory,
                    storiesDisabled: storiesDisabled,
                    hasSeenGroupStoryEducationSheet: hasSeenGroupStoryEducationSheet,
                    hasCompletedUsernameOnboarding: hasCompletedUsernameOnboarding,
                    configure: configure
                    )
        }

    }

}

extension BackupProto.AccountData.PhoneNumberSharingMode : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.AccountData.UsernameLink : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.AccountData.UsernameLink : Hashable {
}
#endif

extension BackupProto.AccountData.UsernameLink : Sendable {
}

extension BackupProto.AccountData.UsernameLink : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.AccountData.UsernameLink"
    }

}

extension BackupProto.AccountData.UsernameLink : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var entropy: Foundation.Data = .init()
        var serverId: Foundation.Data = .init()
        var color: BackupProto.AccountData.UsernameLink.Color? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: entropy = try protoReader.decode(Foundation.Data.self)
            case 2: serverId = try protoReader.decode(Foundation.Data.self)
            case 3: color = try protoReader.decode(BackupProto.AccountData.UsernameLink.Color.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.entropy = entropy
        self.serverId = serverId
        self._color.wrappedValue = try BackupProto.AccountData.UsernameLink.Color.defaultIfMissing(color)
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.entropy)
        try protoWriter.encode(tag: 2, value: self.serverId)
        try protoWriter.encode(tag: 3, value: self.color)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.AccountData.UsernameLink : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.entropy = try container.decode(stringEncoded: Foundation.Data.self, forKey: "entropy")
        self.serverId = try container.decode(stringEncoded: Foundation.Data.self, forKey: "serverId")
        self._color.wrappedValue = try container.decodeIfPresent(BackupProto.AccountData.UsernameLink.Color.self, forKey: "color")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.entropy.isEmpty {
            try container.encode(stringEncoded: self.entropy, forKey: "entropy")
        }
        if includeDefaults || !self.serverId.isEmpty {
            try container.encode(stringEncoded: self.serverId, forKey: "serverId")
        }
        try container.encodeIfPresent(self.color, forKey: "color")
    }

}
#endif

/**
 * Subtypes within BackupProto.AccountData.UsernameLink
 */
extension BackupProto.AccountData.UsernameLink {

    public enum Color : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN = 0
        case BLUE = 1
        case WHITE = 2
        case GREY = 3
        case OLIVE = 4
        case GREEN = 5
        case ORANGE = 6
        case PINK = 7
        case PURPLE = 8

        public static var defaultedValue: BackupProto.AccountData.UsernameLink.Color {
            BackupProto.AccountData.UsernameLink.Color.UNKNOWN
        }
        public var description: String {
            switch self {
            case .UNKNOWN: return "UNKNOWN"
            case .BLUE: return "BLUE"
            case .WHITE: return "WHITE"
            case .GREY: return "GREY"
            case .OLIVE: return "OLIVE"
            case .GREEN: return "GREEN"
            case .ORANGE: return "ORANGE"
            case .PINK: return "PINK"
            case .PURPLE: return "PURPLE"
            }
        }

    }

}

extension BackupProto.AccountData.UsernameLink.Color : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.AccountData.AccountSettings : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.AccountData.AccountSettings : Hashable {
}
#endif

extension BackupProto.AccountData.AccountSettings : Sendable {
}

extension BackupProto.AccountData.AccountSettings : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        self.storage = try BackupProto.AccountData.AccountSettings.Storage(from: protoReader)
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try storage.encode(to: protoWriter)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.AccountData.AccountSettings : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        self.storage = try container.decode(BackupProto.AccountData.AccountSettings.Storage.self)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(storage)
    }

}
#endif

extension BackupProto.AccountData.AccountSettings {

    /**
     * Underlying storage for BackupProto.AccountData.AccountSettings
     */
    public struct Storage {

        public var readReceipts: Bool
        public var sealedSenderIndicators: Bool
        public var typingIndicators: Bool
        public var linkPreviews: Bool
        public var notDiscoverableByPhoneNumber: Bool
        public var preferContactAvatars: Bool
        public var universalExpireTimer: UInt32
        public var preferredReactionEmoji: [String] = []
        public var displayBadgesOnProfile: Bool
        public var keepMutedChatsArchived: Bool
        public var hasSetMyStoriesPrivacy: Bool
        public var hasViewedOnboardingStory: Bool
        public var storiesDisabled: Bool
        @ProtoDefaulted
        public var storyViewReceiptsEnabled: Bool?
        public var hasSeenGroupStoryEducationSheet: Bool
        public var hasCompletedUsernameOnboarding: Bool
        @ProtoDefaulted
        public var phoneNumberSharingMode: BackupProto.AccountData.PhoneNumberSharingMode?
        public var unknownFields: UnknownFields = .init()

        public init(
            readReceipts: Bool,
            sealedSenderIndicators: Bool,
            typingIndicators: Bool,
            linkPreviews: Bool,
            notDiscoverableByPhoneNumber: Bool,
            preferContactAvatars: Bool,
            universalExpireTimer: UInt32,
            displayBadgesOnProfile: Bool,
            keepMutedChatsArchived: Bool,
            hasSetMyStoriesPrivacy: Bool,
            hasViewedOnboardingStory: Bool,
            storiesDisabled: Bool,
            hasSeenGroupStoryEducationSheet: Bool,
            hasCompletedUsernameOnboarding: Bool,
            configure: (inout Self) -> Swift.Void = { _ in }
        ) {
            self.readReceipts = readReceipts
            self.sealedSenderIndicators = sealedSenderIndicators
            self.typingIndicators = typingIndicators
            self.linkPreviews = linkPreviews
            self.notDiscoverableByPhoneNumber = notDiscoverableByPhoneNumber
            self.preferContactAvatars = preferContactAvatars
            self.universalExpireTimer = universalExpireTimer
            self.displayBadgesOnProfile = displayBadgesOnProfile
            self.keepMutedChatsArchived = keepMutedChatsArchived
            self.hasSetMyStoriesPrivacy = hasSetMyStoriesPrivacy
            self.hasViewedOnboardingStory = hasViewedOnboardingStory
            self.storiesDisabled = storiesDisabled
            self.hasSeenGroupStoryEducationSheet = hasSeenGroupStoryEducationSheet
            self.hasCompletedUsernameOnboarding = hasCompletedUsernameOnboarding
            configure(&self)
        }

    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.AccountData.AccountSettings.Storage : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.AccountData.AccountSettings.Storage : Hashable {
}
#endif

extension BackupProto.AccountData.AccountSettings.Storage : Sendable {
}

extension BackupProto.AccountData.AccountSettings.Storage : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.AccountData.AccountSettings"
    }

}

extension BackupProto.AccountData.AccountSettings.Storage : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var readReceipts: Bool = false
        var sealedSenderIndicators: Bool = false
        var typingIndicators: Bool = false
        var linkPreviews: Bool = false
        var notDiscoverableByPhoneNumber: Bool = false
        var preferContactAvatars: Bool = false
        var universalExpireTimer: UInt32 = 0
        var preferredReactionEmoji: [String] = []
        var displayBadgesOnProfile: Bool = false
        var keepMutedChatsArchived: Bool = false
        var hasSetMyStoriesPrivacy: Bool = false
        var hasViewedOnboardingStory: Bool = false
        var storiesDisabled: Bool = false
        var storyViewReceiptsEnabled: Bool? = nil
        var hasSeenGroupStoryEducationSheet: Bool = false
        var hasCompletedUsernameOnboarding: Bool = false
        var phoneNumberSharingMode: BackupProto.AccountData.PhoneNumberSharingMode? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: readReceipts = try protoReader.decode(Bool.self)
            case 2: sealedSenderIndicators = try protoReader.decode(Bool.self)
            case 3: typingIndicators = try protoReader.decode(Bool.self)
            case 4: linkPreviews = try protoReader.decode(Bool.self)
            case 5: notDiscoverableByPhoneNumber = try protoReader.decode(Bool.self)
            case 6: preferContactAvatars = try protoReader.decode(Bool.self)
            case 7: universalExpireTimer = try protoReader.decode(UInt32.self)
            case 8: try protoReader.decode(into: &preferredReactionEmoji)
            case 9: displayBadgesOnProfile = try protoReader.decode(Bool.self)
            case 10: keepMutedChatsArchived = try protoReader.decode(Bool.self)
            case 11: hasSetMyStoriesPrivacy = try protoReader.decode(Bool.self)
            case 12: hasViewedOnboardingStory = try protoReader.decode(Bool.self)
            case 13: storiesDisabled = try protoReader.decode(Bool.self)
            case 14: storyViewReceiptsEnabled = try protoReader.decode(Bool.self)
            case 15: hasSeenGroupStoryEducationSheet = try protoReader.decode(Bool.self)
            case 16: hasCompletedUsernameOnboarding = try protoReader.decode(Bool.self)
            case 17: phoneNumberSharingMode = try protoReader.decode(BackupProto.AccountData.PhoneNumberSharingMode.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.readReceipts = readReceipts
        self.sealedSenderIndicators = sealedSenderIndicators
        self.typingIndicators = typingIndicators
        self.linkPreviews = linkPreviews
        self.notDiscoverableByPhoneNumber = notDiscoverableByPhoneNumber
        self.preferContactAvatars = preferContactAvatars
        self.universalExpireTimer = universalExpireTimer
        self.preferredReactionEmoji = preferredReactionEmoji
        self.displayBadgesOnProfile = displayBadgesOnProfile
        self.keepMutedChatsArchived = keepMutedChatsArchived
        self.hasSetMyStoriesPrivacy = hasSetMyStoriesPrivacy
        self.hasViewedOnboardingStory = hasViewedOnboardingStory
        self.storiesDisabled = storiesDisabled
        self._storyViewReceiptsEnabled.wrappedValue = storyViewReceiptsEnabled
        self.hasSeenGroupStoryEducationSheet = hasSeenGroupStoryEducationSheet
        self.hasCompletedUsernameOnboarding = hasCompletedUsernameOnboarding
        self._phoneNumberSharingMode.wrappedValue = try BackupProto.AccountData.PhoneNumberSharingMode.defaultIfMissing(phoneNumberSharingMode)
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.readReceipts)
        try protoWriter.encode(tag: 2, value: self.sealedSenderIndicators)
        try protoWriter.encode(tag: 3, value: self.typingIndicators)
        try protoWriter.encode(tag: 4, value: self.linkPreviews)
        try protoWriter.encode(tag: 5, value: self.notDiscoverableByPhoneNumber)
        try protoWriter.encode(tag: 6, value: self.preferContactAvatars)
        try protoWriter.encode(tag: 7, value: self.universalExpireTimer)
        try protoWriter.encode(tag: 8, value: self.preferredReactionEmoji)
        try protoWriter.encode(tag: 9, value: self.displayBadgesOnProfile)
        try protoWriter.encode(tag: 10, value: self.keepMutedChatsArchived)
        try protoWriter.encode(tag: 11, value: self.hasSetMyStoriesPrivacy)
        try protoWriter.encode(tag: 12, value: self.hasViewedOnboardingStory)
        try protoWriter.encode(tag: 13, value: self.storiesDisabled)
        try protoWriter.encode(tag: 14, value: self.storyViewReceiptsEnabled)
        try protoWriter.encode(tag: 15, value: self.hasSeenGroupStoryEducationSheet)
        try protoWriter.encode(tag: 16, value: self.hasCompletedUsernameOnboarding)
        try protoWriter.encode(tag: 17, value: self.phoneNumberSharingMode)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.AccountData.AccountSettings.Storage : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.readReceipts = try container.decode(Bool.self, forKey: "readReceipts")
        self.sealedSenderIndicators = try container.decode(Bool.self, forKey: "sealedSenderIndicators")
        self.typingIndicators = try container.decode(Bool.self, forKey: "typingIndicators")
        self.linkPreviews = try container.decode(Bool.self, forKey: "linkPreviews")
        self.notDiscoverableByPhoneNumber = try container.decode(Bool.self, forKey: "notDiscoverableByPhoneNumber")
        self.preferContactAvatars = try container.decode(Bool.self, forKey: "preferContactAvatars")
        self.universalExpireTimer = try container.decode(UInt32.self, forKey: "universalExpireTimer")
        self.preferredReactionEmoji = try container.decodeProtoArray(String.self, forKey: "preferredReactionEmoji")
        self.displayBadgesOnProfile = try container.decode(Bool.self, forKey: "displayBadgesOnProfile")
        self.keepMutedChatsArchived = try container.decode(Bool.self, forKey: "keepMutedChatsArchived")
        self.hasSetMyStoriesPrivacy = try container.decode(Bool.self, forKey: "hasSetMyStoriesPrivacy")
        self.hasViewedOnboardingStory = try container.decode(Bool.self, forKey: "hasViewedOnboardingStory")
        self.storiesDisabled = try container.decode(Bool.self, forKey: "storiesDisabled")
        self._storyViewReceiptsEnabled.wrappedValue = try container.decodeIfPresent(Bool.self, forKey: "storyViewReceiptsEnabled")
        self.hasSeenGroupStoryEducationSheet = try container.decode(Bool.self, forKey: "hasSeenGroupStoryEducationSheet")
        self.hasCompletedUsernameOnboarding = try container.decode(Bool.self, forKey: "hasCompletedUsernameOnboarding")
        self._phoneNumberSharingMode.wrappedValue = try container.decodeIfPresent(BackupProto.AccountData.PhoneNumberSharingMode.self, forKey: "phoneNumberSharingMode")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || self.readReceipts != false {
            try container.encode(self.readReceipts, forKey: "readReceipts")
        }
        if includeDefaults || self.sealedSenderIndicators != false {
            try container.encode(self.sealedSenderIndicators, forKey: "sealedSenderIndicators")
        }
        if includeDefaults || self.typingIndicators != false {
            try container.encode(self.typingIndicators, forKey: "typingIndicators")
        }
        if includeDefaults || self.linkPreviews != false {
            try container.encode(self.linkPreviews, forKey: "linkPreviews")
        }
        if includeDefaults || self.notDiscoverableByPhoneNumber != false {
            try container.encode(self.notDiscoverableByPhoneNumber, forKey: "notDiscoverableByPhoneNumber")
        }
        if includeDefaults || self.preferContactAvatars != false {
            try container.encode(self.preferContactAvatars, forKey: "preferContactAvatars")
        }
        if includeDefaults || self.universalExpireTimer != 0 {
            try container.encode(self.universalExpireTimer, forKey: "universalExpireTimer")
        }
        if includeDefaults || !self.preferredReactionEmoji.isEmpty {
            try container.encodeProtoArray(self.preferredReactionEmoji, forKey: "preferredReactionEmoji")
        }
        if includeDefaults || self.displayBadgesOnProfile != false {
            try container.encode(self.displayBadgesOnProfile, forKey: "displayBadgesOnProfile")
        }
        if includeDefaults || self.keepMutedChatsArchived != false {
            try container.encode(self.keepMutedChatsArchived, forKey: "keepMutedChatsArchived")
        }
        if includeDefaults || self.hasSetMyStoriesPrivacy != false {
            try container.encode(self.hasSetMyStoriesPrivacy, forKey: "hasSetMyStoriesPrivacy")
        }
        if includeDefaults || self.hasViewedOnboardingStory != false {
            try container.encode(self.hasViewedOnboardingStory, forKey: "hasViewedOnboardingStory")
        }
        if includeDefaults || self.storiesDisabled != false {
            try container.encode(self.storiesDisabled, forKey: "storiesDisabled")
        }
        try container.encodeIfPresent(self.storyViewReceiptsEnabled, forKey: "storyViewReceiptsEnabled")
        if includeDefaults || self.hasSeenGroupStoryEducationSheet != false {
            try container.encode(self.hasSeenGroupStoryEducationSheet, forKey: "hasSeenGroupStoryEducationSheet")
        }
        if includeDefaults || self.hasCompletedUsernameOnboarding != false {
            try container.encode(self.hasCompletedUsernameOnboarding, forKey: "hasCompletedUsernameOnboarding")
        }
        try container.encodeIfPresent(self.phoneNumberSharingMode, forKey: "phoneNumberSharingMode")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Recipient : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Recipient : Hashable {
}
#endif

extension BackupProto.Recipient : Sendable {
}

extension BackupProto.Recipient : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.Recipient"
    }

}

extension BackupProto.Recipient : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var id: UInt64 = 0
        var destination: BackupProto.Recipient.Destination? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: id = try protoReader.decode(UInt64.self)
            case 2: destination = .contact(try protoReader.decode(BackupProto.Contact.self))
            case 3: destination = .group(try protoReader.decode(BackupProto.Group.self))
            case 4: destination = .distributionList(try protoReader.decode(BackupProto.DistributionList.self))
            case 5: destination = .selfRecipient(try protoReader.decode(BackupProto.SelfRecipient.self))
            case 6: destination = .releaseNotes(try protoReader.decode(BackupProto.ReleaseNotes.self))
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.id = id
        self.destination = destination
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.id)
        if let destination = self.destination {
            try destination.encode(to: protoWriter)
        }
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.Recipient : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.id = try container.decode(stringEncoded: UInt64.self, forKey: "id")
        if let contact = try container.decodeIfPresent(BackupProto.Contact.self, forKey: "contact") {
            self.destination = .contact(contact)
        } else if let group = try container.decodeIfPresent(BackupProto.Group.self, forKey: "group") {
            self.destination = .group(group)
        } else if let distributionList = try container.decodeIfPresent(BackupProto.DistributionList.self, forKey: "distributionList") {
            self.destination = .distributionList(distributionList)
        } else if let selfRecipient = try container.decodeIfPresent(BackupProto.SelfRecipient.self, forKey: "selfRecipient") {
            self.destination = .selfRecipient(selfRecipient)
        } else if let releaseNotes = try container.decodeIfPresent(BackupProto.ReleaseNotes.self, forKey: "releaseNotes") {
            self.destination = .releaseNotes(releaseNotes)
        } else {
            self.destination = nil
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || self.id != 0 {
            try container.encode(stringEncoded: self.id, forKey: "id")
        }
        switch self.destination {
        case .contact(let contact): try container.encode(contact, forKey: "contact")
        case .group(let group): try container.encode(group, forKey: "group")
        case .distributionList(let distributionList): try container.encode(distributionList, forKey: "distributionList")
        case .selfRecipient(let selfRecipient): try container.encode(selfRecipient, forKey: "selfRecipient")
        case .releaseNotes(let releaseNotes): try container.encode(releaseNotes, forKey: "releaseNotes")
        case Optional.none: break
        }
    }

}
#endif

/**
 * Subtypes within BackupProto.Recipient
 */
extension BackupProto.Recipient {

    public enum Destination {

        case contact(BackupProto.Contact)
        case group(BackupProto.Group)
        case distributionList(BackupProto.DistributionList)
        case selfRecipient(BackupProto.SelfRecipient)
        case releaseNotes(BackupProto.ReleaseNotes)

        fileprivate func encode(to protoWriter: ProtoWriter) throws {
            switch self {
            case .contact(let contact): try protoWriter.encode(tag: 2, value: contact)
            case .group(let group): try protoWriter.encode(tag: 3, value: group)
            case .distributionList(let distributionList): try protoWriter.encode(tag: 4, value: distributionList)
            case .selfRecipient(let selfRecipient): try protoWriter.encode(tag: 5, value: selfRecipient)
            case .releaseNotes(let releaseNotes): try protoWriter.encode(tag: 6, value: releaseNotes)
            }
        }

    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Recipient.Destination : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Recipient.Destination : Hashable {
}
#endif

extension BackupProto.Recipient.Destination : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Contact : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Contact : Hashable {
}
#endif

extension BackupProto.Contact : Sendable {
}

extension BackupProto.Contact : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.Contact"
    }

}

extension BackupProto.Contact : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var aci: Foundation.Data? = nil
        var pni: Foundation.Data? = nil
        var username: String? = nil
        var e164: UInt64? = nil
        var blocked: Bool = false
        var hidden: Bool = false
        var registered: BackupProto.Contact.Registered? = nil
        var unregisteredTimestamp: UInt64 = 0
        var profileKey: Foundation.Data? = nil
        var profileSharing: Bool = false
        var profileGivenName: String? = nil
        var profileFamilyName: String? = nil
        var hideStory: Bool = false

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: aci = try protoReader.decode(Foundation.Data.self)
            case 2: pni = try protoReader.decode(Foundation.Data.self)
            case 3: username = try protoReader.decode(String.self)
            case 4: e164 = try protoReader.decode(UInt64.self)
            case 5: blocked = try protoReader.decode(Bool.self)
            case 6: hidden = try protoReader.decode(Bool.self)
            case 7: registered = try protoReader.decode(BackupProto.Contact.Registered.self)
            case 8: unregisteredTimestamp = try protoReader.decode(UInt64.self)
            case 9: profileKey = try protoReader.decode(Foundation.Data.self)
            case 10: profileSharing = try protoReader.decode(Bool.self)
            case 11: profileGivenName = try protoReader.decode(String.self)
            case 12: profileFamilyName = try protoReader.decode(String.self)
            case 13: hideStory = try protoReader.decode(Bool.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._aci.wrappedValue = aci
        self._pni.wrappedValue = pni
        self._username.wrappedValue = username
        self._e164.wrappedValue = e164
        self.blocked = blocked
        self.hidden = hidden
        self._registered.wrappedValue = try BackupProto.Contact.Registered.defaultIfMissing(registered)
        self.unregisteredTimestamp = unregisteredTimestamp
        self._profileKey.wrappedValue = profileKey
        self.profileSharing = profileSharing
        self._profileGivenName.wrappedValue = profileGivenName
        self._profileFamilyName.wrappedValue = profileFamilyName
        self.hideStory = hideStory
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.aci)
        try protoWriter.encode(tag: 2, value: self.pni)
        try protoWriter.encode(tag: 3, value: self.username)
        try protoWriter.encode(tag: 4, value: self.e164)
        try protoWriter.encode(tag: 5, value: self.blocked)
        try protoWriter.encode(tag: 6, value: self.hidden)
        try protoWriter.encode(tag: 7, value: self.registered)
        try protoWriter.encode(tag: 8, value: self.unregisteredTimestamp)
        try protoWriter.encode(tag: 9, value: self.profileKey)
        try protoWriter.encode(tag: 10, value: self.profileSharing)
        try protoWriter.encode(tag: 11, value: self.profileGivenName)
        try protoWriter.encode(tag: 12, value: self.profileFamilyName)
        try protoWriter.encode(tag: 13, value: self.hideStory)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.Contact : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._aci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "aci")
        self._pni.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "pni")
        self._username.wrappedValue = try container.decodeIfPresent(String.self, forKey: "username")
        self._e164.wrappedValue = try container.decodeIfPresent(stringEncoded: UInt64.self, forKey: "e164")
        self.blocked = try container.decode(Bool.self, forKey: "blocked")
        self.hidden = try container.decode(Bool.self, forKey: "hidden")
        self._registered.wrappedValue = try container.decodeIfPresent(BackupProto.Contact.Registered.self, forKey: "registered")
        self.unregisteredTimestamp = try container.decode(stringEncoded: UInt64.self, forKey: "unregisteredTimestamp")
        self._profileKey.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "profileKey")
        self.profileSharing = try container.decode(Bool.self, forKey: "profileSharing")
        self._profileGivenName.wrappedValue = try container.decodeIfPresent(String.self, forKey: "profileGivenName")
        self._profileFamilyName.wrappedValue = try container.decodeIfPresent(String.self, forKey: "profileFamilyName")
        self.hideStory = try container.decode(Bool.self, forKey: "hideStory")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(stringEncoded: self.aci, forKey: "aci")
        try container.encodeIfPresent(stringEncoded: self.pni, forKey: "pni")
        try container.encodeIfPresent(self.username, forKey: "username")
        try container.encodeIfPresent(stringEncoded: self.e164, forKey: "e164")
        if includeDefaults || self.blocked != false {
            try container.encode(self.blocked, forKey: "blocked")
        }
        if includeDefaults || self.hidden != false {
            try container.encode(self.hidden, forKey: "hidden")
        }
        try container.encodeIfPresent(self.registered, forKey: "registered")
        if includeDefaults || self.unregisteredTimestamp != 0 {
            try container.encode(stringEncoded: self.unregisteredTimestamp, forKey: "unregisteredTimestamp")
        }
        try container.encodeIfPresent(stringEncoded: self.profileKey, forKey: "profileKey")
        if includeDefaults || self.profileSharing != false {
            try container.encode(self.profileSharing, forKey: "profileSharing")
        }
        try container.encodeIfPresent(self.profileGivenName, forKey: "profileGivenName")
        try container.encodeIfPresent(self.profileFamilyName, forKey: "profileFamilyName")
        if includeDefaults || self.hideStory != false {
            try container.encode(self.hideStory, forKey: "hideStory")
        }
    }

}
#endif

/**
 * Subtypes within BackupProto.Contact
 */
extension BackupProto.Contact {

    public enum Registered : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN = 0
        case REGISTERED = 1
        case NOT_REGISTERED = 2

        public static var defaultedValue: BackupProto.Contact.Registered {
            BackupProto.Contact.Registered.UNKNOWN
        }
        public var description: String {
            switch self {
            case .UNKNOWN: return "UNKNOWN"
            case .REGISTERED: return "REGISTERED"
            case .NOT_REGISTERED: return "NOT_REGISTERED"
            }
        }

    }

}

extension BackupProto.Contact.Registered : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Group : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Group : Hashable {
}
#endif

extension BackupProto.Group : Sendable {
}

extension BackupProto.Group : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.Group"
    }

}

extension BackupProto.Group : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var masterKey: Foundation.Data = .init()
        var whitelisted: Bool = false
        var hideStory: Bool = false
        var storySendMode: BackupProto.Group.StorySendMode? = nil
        var snapshot: BackupProto.Group.GroupSnapshot? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: masterKey = try protoReader.decode(Foundation.Data.self)
            case 2: whitelisted = try protoReader.decode(Bool.self)
            case 3: hideStory = try protoReader.decode(Bool.self)
            case 4: storySendMode = try protoReader.decode(BackupProto.Group.StorySendMode.self)
            case 5: snapshot = try protoReader.decode(BackupProto.Group.GroupSnapshot.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.masterKey = masterKey
        self.whitelisted = whitelisted
        self.hideStory = hideStory
        self._storySendMode.wrappedValue = try BackupProto.Group.StorySendMode.defaultIfMissing(storySendMode)
        self.snapshot = snapshot
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.masterKey)
        try protoWriter.encode(tag: 2, value: self.whitelisted)
        try protoWriter.encode(tag: 3, value: self.hideStory)
        try protoWriter.encode(tag: 4, value: self.storySendMode)
        try protoWriter.encode(tag: 5, value: self.snapshot)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.Group : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.masterKey = try container.decode(stringEncoded: Foundation.Data.self, forKey: "masterKey")
        self.whitelisted = try container.decode(Bool.self, forKey: "whitelisted")
        self.hideStory = try container.decode(Bool.self, forKey: "hideStory")
        self._storySendMode.wrappedValue = try container.decodeIfPresent(BackupProto.Group.StorySendMode.self, forKey: "storySendMode")
        self.snapshot = try container.decodeIfPresent(BackupProto.Group.GroupSnapshot.self, forKey: "snapshot")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.masterKey.isEmpty {
            try container.encode(stringEncoded: self.masterKey, forKey: "masterKey")
        }
        if includeDefaults || self.whitelisted != false {
            try container.encode(self.whitelisted, forKey: "whitelisted")
        }
        if includeDefaults || self.hideStory != false {
            try container.encode(self.hideStory, forKey: "hideStory")
        }
        try container.encodeIfPresent(self.storySendMode, forKey: "storySendMode")
        try container.encodeIfPresent(self.snapshot, forKey: "snapshot")
    }

}
#endif

/**
 * Subtypes within BackupProto.Group
 */
extension BackupProto.Group {

    public enum StorySendMode : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case DEFAULT = 0
        case DISABLED = 1
        case ENABLED = 2

        public static var defaultedValue: BackupProto.Group.StorySendMode {
            BackupProto.Group.StorySendMode.DEFAULT
        }
        public var description: String {
            switch self {
            case .DEFAULT: return "DEFAULT"
            case .DISABLED: return "DISABLED"
            case .ENABLED: return "ENABLED"
            }
        }

    }

    /**
     * A copy of the static Group state defined in `Groups.proto`, with all
     * plaintext fields (contrasted with that proto's encrypted fields).
     */
    public struct GroupSnapshot {

        public var publicKey: Foundation.Data
        public var title: BackupProto.Group.GroupAttributeBlob?
        public var descriptionText: BackupProto.Group.GroupAttributeBlob?
        public var avatarUrl: String
        public var disappearingMessagesTimer: BackupProto.Group.GroupAttributeBlob?
        public var accessControl: BackupProto.Group.AccessControl?
        public var version: UInt32
        public var members: [BackupProto.Group.Member] = []
        public var membersPendingProfileKey: [BackupProto.Group.MemberPendingProfileKey] = []
        public var membersPendingAdminApproval: [BackupProto.Group.MemberPendingAdminApproval] = []
        public var inviteLinkPassword: Foundation.Data
        public var announcementsOnly: Bool
        public var membersBanned: [BackupProto.Group.MemberBanned] = []
        public var unknownFields: UnknownFields = .init()

        public init(
            publicKey: Foundation.Data,
            avatarUrl: String,
            version: UInt32,
            inviteLinkPassword: Foundation.Data,
            announcementsOnly: Bool,
            configure: (inout Self) -> Swift.Void = { _ in }
        ) {
            self.publicKey = publicKey
            self.avatarUrl = avatarUrl
            self.version = version
            self.inviteLinkPassword = inviteLinkPassword
            self.announcementsOnly = announcementsOnly
            configure(&self)
        }

    }

    public struct GroupAttributeBlob {

        public var content: BackupProto.Group.GroupAttributeBlob.Content?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct Member {

        public var userId: Foundation.Data
        public var role: BackupProto.Group.Member.Role
        public var profileKey: Foundation.Data
        public var joinedAtVersion: UInt32
        public var unknownFields: UnknownFields = .init()

        public init(
            userId: Foundation.Data,
            role: BackupProto.Group.Member.Role,
            profileKey: Foundation.Data,
            joinedAtVersion: UInt32
        ) {
            self.userId = userId
            self.role = role
            self.profileKey = profileKey
            self.joinedAtVersion = joinedAtVersion
        }

    }

    public struct MemberPendingProfileKey {

        public var member: BackupProto.Group.Member?
        public var addedByUserId: Foundation.Data
        public var timestamp: UInt64
        public var unknownFields: UnknownFields = .init()

        public init(
            addedByUserId: Foundation.Data,
            timestamp: UInt64,
            configure: (inout Self) -> Swift.Void = { _ in }
        ) {
            self.addedByUserId = addedByUserId
            self.timestamp = timestamp
            configure(&self)
        }

    }

    public struct MemberPendingAdminApproval {

        public var userId: Foundation.Data
        public var profileKey: Foundation.Data
        public var timestamp: UInt64
        public var unknownFields: UnknownFields = .init()

        public init(
            userId: Foundation.Data,
            profileKey: Foundation.Data,
            timestamp: UInt64
        ) {
            self.userId = userId
            self.profileKey = profileKey
            self.timestamp = timestamp
        }

    }

    public struct MemberBanned {

        public var userId: Foundation.Data
        public var timestamp: UInt64
        public var unknownFields: UnknownFields = .init()

        public init(userId: Foundation.Data, timestamp: UInt64) {
            self.userId = userId
            self.timestamp = timestamp
        }

    }

    public struct AccessControl {

        public var attributes: BackupProto.Group.AccessControl.AccessRequired
        public var members: BackupProto.Group.AccessControl.AccessRequired
        public var addFromInviteLink: BackupProto.Group.AccessControl.AccessRequired
        public var unknownFields: UnknownFields = .init()

        public init(
            attributes: BackupProto.Group.AccessControl.AccessRequired,
            members: BackupProto.Group.AccessControl.AccessRequired,
            addFromInviteLink: BackupProto.Group.AccessControl.AccessRequired
        ) {
            self.attributes = attributes
            self.members = members
            self.addFromInviteLink = addFromInviteLink
        }

    }

}

extension BackupProto.Group.StorySendMode : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Group.GroupSnapshot : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Group.GroupSnapshot : Hashable {
}
#endif

extension BackupProto.Group.GroupSnapshot : Sendable {
}

extension BackupProto.Group.GroupSnapshot : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.Group.GroupSnapshot"
    }

}

extension BackupProto.Group.GroupSnapshot : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var publicKey: Foundation.Data = .init()
        var title: BackupProto.Group.GroupAttributeBlob? = nil
        var descriptionText: BackupProto.Group.GroupAttributeBlob? = nil
        var avatarUrl: String = ""
        var disappearingMessagesTimer: BackupProto.Group.GroupAttributeBlob? = nil
        var accessControl: BackupProto.Group.AccessControl? = nil
        var version: UInt32 = 0
        var members: [BackupProto.Group.Member] = []
        var membersPendingProfileKey: [BackupProto.Group.MemberPendingProfileKey] = []
        var membersPendingAdminApproval: [BackupProto.Group.MemberPendingAdminApproval] = []
        var inviteLinkPassword: Foundation.Data = .init()
        var announcementsOnly: Bool = false
        var membersBanned: [BackupProto.Group.MemberBanned] = []

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: publicKey = try protoReader.decode(Foundation.Data.self)
            case 2: title = try protoReader.decode(BackupProto.Group.GroupAttributeBlob.self)
            case 11: descriptionText = try protoReader.decode(BackupProto.Group.GroupAttributeBlob.self)
            case 3: avatarUrl = try protoReader.decode(String.self)
            case 4: disappearingMessagesTimer = try protoReader.decode(BackupProto.Group.GroupAttributeBlob.self)
            case 5: accessControl = try protoReader.decode(BackupProto.Group.AccessControl.self)
            case 6: version = try protoReader.decode(UInt32.self)
            case 7: try protoReader.decode(into: &members)
            case 8: try protoReader.decode(into: &membersPendingProfileKey)
            case 9: try protoReader.decode(into: &membersPendingAdminApproval)
            case 10: inviteLinkPassword = try protoReader.decode(Foundation.Data.self)
            case 12: announcementsOnly = try protoReader.decode(Bool.self)
            case 13: try protoReader.decode(into: &membersBanned)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.publicKey = publicKey
        self.title = title
        self.descriptionText = descriptionText
        self.avatarUrl = avatarUrl
        self.disappearingMessagesTimer = disappearingMessagesTimer
        self.accessControl = accessControl
        self.version = version
        self.members = members
        self.membersPendingProfileKey = membersPendingProfileKey
        self.membersPendingAdminApproval = membersPendingAdminApproval
        self.inviteLinkPassword = inviteLinkPassword
        self.announcementsOnly = announcementsOnly
        self.membersBanned = membersBanned
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.publicKey)
        try protoWriter.encode(tag: 2, value: self.title)
        try protoWriter.encode(tag: 11, value: self.descriptionText)
        try protoWriter.encode(tag: 3, value: self.avatarUrl)
        try protoWriter.encode(tag: 4, value: self.disappearingMessagesTimer)
        try protoWriter.encode(tag: 5, value: self.accessControl)
        try protoWriter.encode(tag: 6, value: self.version)
        try protoWriter.encode(tag: 7, value: self.members)
        try protoWriter.encode(tag: 8, value: self.membersPendingProfileKey)
        try protoWriter.encode(tag: 9, value: self.membersPendingAdminApproval)
        try protoWriter.encode(tag: 10, value: self.inviteLinkPassword)
        try protoWriter.encode(tag: 12, value: self.announcementsOnly)
        try protoWriter.encode(tag: 13, value: self.membersBanned)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.Group.GroupSnapshot : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.publicKey = try container.decode(stringEncoded: Foundation.Data.self, forKey: "publicKey")
        self.title = try container.decodeIfPresent(BackupProto.Group.GroupAttributeBlob.self, forKey: "title")
        self.descriptionText = try container.decodeIfPresent(BackupProto.Group.GroupAttributeBlob.self, forKey: "descriptionText")
        self.avatarUrl = try container.decode(String.self, forKey: "avatarUrl")
        self.disappearingMessagesTimer = try container.decodeIfPresent(BackupProto.Group.GroupAttributeBlob.self, forKey: "disappearingMessagesTimer")
        self.accessControl = try container.decodeIfPresent(BackupProto.Group.AccessControl.self, forKey: "accessControl")
        self.version = try container.decode(UInt32.self, forKey: "version")
        self.members = try container.decodeProtoArray(BackupProto.Group.Member.self, forKey: "members")
        self.membersPendingProfileKey = try container.decodeProtoArray(BackupProto.Group.MemberPendingProfileKey.self, forKey: "membersPendingProfileKey")
        self.membersPendingAdminApproval = try container.decodeProtoArray(BackupProto.Group.MemberPendingAdminApproval.self, forKey: "membersPendingAdminApproval")
        self.inviteLinkPassword = try container.decode(stringEncoded: Foundation.Data.self, forKey: "inviteLinkPassword")
        self.announcementsOnly = try container.decode(Bool.self, forKey: "announcementsOnly")
        self.membersBanned = try container.decodeProtoArray(BackupProto.Group.MemberBanned.self, forKey: "membersBanned")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.publicKey.isEmpty {
            try container.encode(stringEncoded: self.publicKey, forKey: "publicKey")
        }
        try container.encodeIfPresent(self.title, forKey: "title")
        try container.encodeIfPresent(self.descriptionText, forKey: "descriptionText")
        if includeDefaults || !self.avatarUrl.isEmpty {
            try container.encode(self.avatarUrl, forKey: "avatarUrl")
        }
        try container.encodeIfPresent(self.disappearingMessagesTimer, forKey: "disappearingMessagesTimer")
        try container.encodeIfPresent(self.accessControl, forKey: "accessControl")
        if includeDefaults || self.version != 0 {
            try container.encode(self.version, forKey: "version")
        }
        if includeDefaults || !self.members.isEmpty {
            try container.encodeProtoArray(self.members, forKey: "members")
        }
        if includeDefaults || !self.membersPendingProfileKey.isEmpty {
            try container.encodeProtoArray(self.membersPendingProfileKey, forKey: "membersPendingProfileKey")
        }
        if includeDefaults || !self.membersPendingAdminApproval.isEmpty {
            try container.encodeProtoArray(self.membersPendingAdminApproval, forKey: "membersPendingAdminApproval")
        }
        if includeDefaults || !self.inviteLinkPassword.isEmpty {
            try container.encode(stringEncoded: self.inviteLinkPassword, forKey: "inviteLinkPassword")
        }
        if includeDefaults || self.announcementsOnly != false {
            try container.encode(self.announcementsOnly, forKey: "announcementsOnly")
        }
        if includeDefaults || !self.membersBanned.isEmpty {
            try container.encodeProtoArray(self.membersBanned, forKey: "membersBanned")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Group.GroupAttributeBlob : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Group.GroupAttributeBlob : Hashable {
}
#endif

extension BackupProto.Group.GroupAttributeBlob : Sendable {
}

extension BackupProto.Group.GroupAttributeBlob : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.Group.GroupAttributeBlob {
        BackupProto.Group.GroupAttributeBlob()
    }
}

extension BackupProto.Group.GroupAttributeBlob : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.Group.GroupAttributeBlob"
    }

}

extension BackupProto.Group.GroupAttributeBlob : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var content: BackupProto.Group.GroupAttributeBlob.Content? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: content = .title(try protoReader.decode(String.self))
            case 2: content = .avatar(try protoReader.decode(Foundation.Data.self))
            case 3: content = .disappearingMessagesDuration(try protoReader.decode(UInt32.self))
            case 4: content = .descriptionText(try protoReader.decode(String.self))
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.content = content
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        if let content = self.content {
            try content.encode(to: protoWriter)
        }
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.Group.GroupAttributeBlob : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        if let title = try container.decodeIfPresent(String.self, forKey: "title") {
            self.content = .title(title)
        } else if let avatar = try container.decodeIfPresent(Foundation.Data.self, forKey: "avatar") {
            self.content = .avatar(avatar)
        } else if let disappearingMessagesDuration = try container.decodeIfPresent(UInt32.self, forKey: "disappearingMessagesDuration") {
            self.content = .disappearingMessagesDuration(disappearingMessagesDuration)
        } else if let descriptionText = try container.decodeIfPresent(String.self, forKey: "descriptionText") {
            self.content = .descriptionText(descriptionText)
        } else {
            self.content = nil
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        switch self.content {
        case .title(let title): try container.encode(title, forKey: "title")
        case .avatar(let avatar): try container.encode(avatar, forKey: "avatar")
        case .disappearingMessagesDuration(let disappearingMessagesDuration): try container.encode(disappearingMessagesDuration, forKey: "disappearingMessagesDuration")
        case .descriptionText(let descriptionText): try container.encode(descriptionText, forKey: "descriptionText")
        case Optional.none: break
        }
    }

}
#endif

/**
 * Subtypes within BackupProto.Group.GroupAttributeBlob
 */
extension BackupProto.Group.GroupAttributeBlob {

    public enum Content {

        case title(String)
        case avatar(Foundation.Data)
        case disappearingMessagesDuration(UInt32)
        case descriptionText(String)

        fileprivate func encode(to protoWriter: ProtoWriter) throws {
            switch self {
            case .title(let title): try protoWriter.encode(tag: 1, value: title)
            case .avatar(let avatar): try protoWriter.encode(tag: 2, value: avatar)
            case .disappearingMessagesDuration(let disappearingMessagesDuration): try protoWriter.encode(tag: 3, value: disappearingMessagesDuration)
            case .descriptionText(let descriptionText): try protoWriter.encode(tag: 4, value: descriptionText)
            }
        }

    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Group.GroupAttributeBlob.Content : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Group.GroupAttributeBlob.Content : Hashable {
}
#endif

extension BackupProto.Group.GroupAttributeBlob.Content : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Group.Member : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Group.Member : Hashable {
}
#endif

extension BackupProto.Group.Member : Sendable {
}

extension BackupProto.Group.Member : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.Group.Member"
    }

}

extension BackupProto.Group.Member : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var userId: Foundation.Data = .init()
        var role: BackupProto.Group.Member.Role? = nil
        var profileKey: Foundation.Data = .init()
        var joinedAtVersion: UInt32 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: userId = try protoReader.decode(Foundation.Data.self)
            case 2: role = try protoReader.decode(BackupProto.Group.Member.Role.self)
            case 3: profileKey = try protoReader.decode(Foundation.Data.self)
            case 5: joinedAtVersion = try protoReader.decode(UInt32.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.userId = userId
        self.role = try BackupProto.Group.Member.Role.defaultIfMissing(role)
        self.profileKey = profileKey
        self.joinedAtVersion = joinedAtVersion
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.userId)
        try protoWriter.encode(tag: 2, value: self.role)
        try protoWriter.encode(tag: 3, value: self.profileKey)
        try protoWriter.encode(tag: 5, value: self.joinedAtVersion)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.Group.Member : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.userId = try container.decode(stringEncoded: Foundation.Data.self, forKey: "userId")
        self.role = try container.decode(BackupProto.Group.Member.Role.self, forKey: "role")
        self.profileKey = try container.decode(stringEncoded: Foundation.Data.self, forKey: "profileKey")
        self.joinedAtVersion = try container.decode(UInt32.self, forKey: "joinedAtVersion")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.userId.isEmpty {
            try container.encode(stringEncoded: self.userId, forKey: "userId")
        }
        if includeDefaults || self.role.rawValue != 0 {
            try container.encode(self.role, forKey: "role")
        }
        if includeDefaults || !self.profileKey.isEmpty {
            try container.encode(stringEncoded: self.profileKey, forKey: "profileKey")
        }
        if includeDefaults || self.joinedAtVersion != 0 {
            try container.encode(self.joinedAtVersion, forKey: "joinedAtVersion")
        }
    }

}
#endif

/**
 * Subtypes within BackupProto.Group.Member
 */
extension BackupProto.Group.Member {

    public enum Role : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN = 0
        case DEFAULT = 1
        case ADMINISTRATOR = 2

        public static var defaultedValue: BackupProto.Group.Member.Role {
            BackupProto.Group.Member.Role.UNKNOWN
        }
        public var description: String {
            switch self {
            case .UNKNOWN: return "UNKNOWN"
            case .DEFAULT: return "DEFAULT"
            case .ADMINISTRATOR: return "ADMINISTRATOR"
            }
        }

    }

}

extension BackupProto.Group.Member.Role : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Group.MemberPendingProfileKey : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Group.MemberPendingProfileKey : Hashable {
}
#endif

extension BackupProto.Group.MemberPendingProfileKey : Sendable {
}

extension BackupProto.Group.MemberPendingProfileKey : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.Group.MemberPendingProfileKey"
    }

}

extension BackupProto.Group.MemberPendingProfileKey : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var member: BackupProto.Group.Member? = nil
        var addedByUserId: Foundation.Data = .init()
        var timestamp: UInt64 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: member = try protoReader.decode(BackupProto.Group.Member.self)
            case 2: addedByUserId = try protoReader.decode(Foundation.Data.self)
            case 3: timestamp = try protoReader.decode(UInt64.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.member = member
        self.addedByUserId = addedByUserId
        self.timestamp = timestamp
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.member)
        try protoWriter.encode(tag: 2, value: self.addedByUserId)
        try protoWriter.encode(tag: 3, value: self.timestamp)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.Group.MemberPendingProfileKey : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.member = try container.decodeIfPresent(BackupProto.Group.Member.self, forKey: "member")
        self.addedByUserId = try container.decode(stringEncoded: Foundation.Data.self, forKey: "addedByUserId")
        self.timestamp = try container.decode(stringEncoded: UInt64.self, forKey: "timestamp")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(self.member, forKey: "member")
        if includeDefaults || !self.addedByUserId.isEmpty {
            try container.encode(stringEncoded: self.addedByUserId, forKey: "addedByUserId")
        }
        if includeDefaults || self.timestamp != 0 {
            try container.encode(stringEncoded: self.timestamp, forKey: "timestamp")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Group.MemberPendingAdminApproval : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Group.MemberPendingAdminApproval : Hashable {
}
#endif

extension BackupProto.Group.MemberPendingAdminApproval : Sendable {
}

extension BackupProto.Group.MemberPendingAdminApproval : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.Group.MemberPendingAdminApproval"
    }

}

extension BackupProto.Group.MemberPendingAdminApproval : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var userId: Foundation.Data = .init()
        var profileKey: Foundation.Data = .init()
        var timestamp: UInt64 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: userId = try protoReader.decode(Foundation.Data.self)
            case 2: profileKey = try protoReader.decode(Foundation.Data.self)
            case 4: timestamp = try protoReader.decode(UInt64.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.userId = userId
        self.profileKey = profileKey
        self.timestamp = timestamp
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.userId)
        try protoWriter.encode(tag: 2, value: self.profileKey)
        try protoWriter.encode(tag: 4, value: self.timestamp)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.Group.MemberPendingAdminApproval : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.userId = try container.decode(stringEncoded: Foundation.Data.self, forKey: "userId")
        self.profileKey = try container.decode(stringEncoded: Foundation.Data.self, forKey: "profileKey")
        self.timestamp = try container.decode(stringEncoded: UInt64.self, forKey: "timestamp")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.userId.isEmpty {
            try container.encode(stringEncoded: self.userId, forKey: "userId")
        }
        if includeDefaults || !self.profileKey.isEmpty {
            try container.encode(stringEncoded: self.profileKey, forKey: "profileKey")
        }
        if includeDefaults || self.timestamp != 0 {
            try container.encode(stringEncoded: self.timestamp, forKey: "timestamp")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Group.MemberBanned : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Group.MemberBanned : Hashable {
}
#endif

extension BackupProto.Group.MemberBanned : Sendable {
}

extension BackupProto.Group.MemberBanned : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.Group.MemberBanned"
    }

}

extension BackupProto.Group.MemberBanned : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var userId: Foundation.Data = .init()
        var timestamp: UInt64 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: userId = try protoReader.decode(Foundation.Data.self)
            case 2: timestamp = try protoReader.decode(UInt64.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.userId = userId
        self.timestamp = timestamp
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.userId)
        try protoWriter.encode(tag: 2, value: self.timestamp)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.Group.MemberBanned : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.userId = try container.decode(stringEncoded: Foundation.Data.self, forKey: "userId")
        self.timestamp = try container.decode(stringEncoded: UInt64.self, forKey: "timestamp")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.userId.isEmpty {
            try container.encode(stringEncoded: self.userId, forKey: "userId")
        }
        if includeDefaults || self.timestamp != 0 {
            try container.encode(stringEncoded: self.timestamp, forKey: "timestamp")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Group.AccessControl : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Group.AccessControl : Hashable {
}
#endif

extension BackupProto.Group.AccessControl : Sendable {
}

extension BackupProto.Group.AccessControl : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.Group.AccessControl"
    }

}

extension BackupProto.Group.AccessControl : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var attributes: BackupProto.Group.AccessControl.AccessRequired? = nil
        var members: BackupProto.Group.AccessControl.AccessRequired? = nil
        var addFromInviteLink: BackupProto.Group.AccessControl.AccessRequired? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: attributes = try protoReader.decode(BackupProto.Group.AccessControl.AccessRequired.self)
            case 2: members = try protoReader.decode(BackupProto.Group.AccessControl.AccessRequired.self)
            case 3: addFromInviteLink = try protoReader.decode(BackupProto.Group.AccessControl.AccessRequired.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.attributes = try BackupProto.Group.AccessControl.AccessRequired.defaultIfMissing(attributes)
        self.members = try BackupProto.Group.AccessControl.AccessRequired.defaultIfMissing(members)
        self.addFromInviteLink = try BackupProto.Group.AccessControl.AccessRequired.defaultIfMissing(addFromInviteLink)
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.attributes)
        try protoWriter.encode(tag: 2, value: self.members)
        try protoWriter.encode(tag: 3, value: self.addFromInviteLink)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.Group.AccessControl : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.attributes = try container.decode(BackupProto.Group.AccessControl.AccessRequired.self, forKey: "attributes")
        self.members = try container.decode(BackupProto.Group.AccessControl.AccessRequired.self, forKey: "members")
        self.addFromInviteLink = try container.decode(BackupProto.Group.AccessControl.AccessRequired.self, forKey: "addFromInviteLink")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || self.attributes.rawValue != 0 {
            try container.encode(self.attributes, forKey: "attributes")
        }
        if includeDefaults || self.members.rawValue != 0 {
            try container.encode(self.members, forKey: "members")
        }
        if includeDefaults || self.addFromInviteLink.rawValue != 0 {
            try container.encode(self.addFromInviteLink, forKey: "addFromInviteLink")
        }
    }

}
#endif

/**
 * Subtypes within BackupProto.Group.AccessControl
 */
extension BackupProto.Group.AccessControl {

    public enum AccessRequired : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN = 0
        case ANY = 1
        case MEMBER = 2
        case ADMINISTRATOR = 3
        case UNSATISFIABLE = 4

        public static var defaultedValue: BackupProto.Group.AccessControl.AccessRequired {
            BackupProto.Group.AccessControl.AccessRequired.UNKNOWN
        }
        public var description: String {
            switch self {
            case .UNKNOWN: return "UNKNOWN"
            case .ANY: return "ANY"
            case .MEMBER: return "MEMBER"
            case .ADMINISTRATOR: return "ADMINISTRATOR"
            case .UNSATISFIABLE: return "UNSATISFIABLE"
            }
        }

    }

}

extension BackupProto.Group.AccessControl.AccessRequired : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.SelfRecipient : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.SelfRecipient : Hashable {
}
#endif

extension BackupProto.SelfRecipient : Sendable {
}

extension BackupProto.SelfRecipient : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.SelfRecipient {
        BackupProto.SelfRecipient()
    }
}

extension BackupProto.SelfRecipient : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.SelfRecipient"
    }

}

extension BackupProto.SelfRecipient : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.SelfRecipient : Codable {

    public enum CodingKeys : CodingKey {
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.ReleaseNotes : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.ReleaseNotes : Hashable {
}
#endif

extension BackupProto.ReleaseNotes : Sendable {
}

extension BackupProto.ReleaseNotes : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.ReleaseNotes {
        BackupProto.ReleaseNotes()
    }
}

extension BackupProto.ReleaseNotes : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.ReleaseNotes"
    }

}

extension BackupProto.ReleaseNotes : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.ReleaseNotes : Codable {

    public enum CodingKeys : CodingKey {
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Chat : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Chat : Hashable {
}
#endif

extension BackupProto.Chat : Sendable {
}

extension BackupProto.Chat : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.Chat"
    }

}

extension BackupProto.Chat : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var id: UInt64 = 0
        var recipientId: UInt64 = 0
        var archived: Bool = false
        var pinnedOrder: UInt32 = 0
        var expirationTimerMs: UInt64 = 0
        var muteUntilMs: UInt64 = 0
        var markedUnread: Bool = false
        var dontNotifyForMentionsIfMuted: Bool = false
        var wallpaper: BackupProto.FilePointer? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: id = try protoReader.decode(UInt64.self)
            case 2: recipientId = try protoReader.decode(UInt64.self)
            case 3: archived = try protoReader.decode(Bool.self)
            case 4: pinnedOrder = try protoReader.decode(UInt32.self)
            case 5: expirationTimerMs = try protoReader.decode(UInt64.self)
            case 6: muteUntilMs = try protoReader.decode(UInt64.self)
            case 7: markedUnread = try protoReader.decode(Bool.self)
            case 8: dontNotifyForMentionsIfMuted = try protoReader.decode(Bool.self)
            case 9: wallpaper = try protoReader.decode(BackupProto.FilePointer.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.id = id
        self.recipientId = recipientId
        self.archived = archived
        self.pinnedOrder = pinnedOrder
        self.expirationTimerMs = expirationTimerMs
        self.muteUntilMs = muteUntilMs
        self.markedUnread = markedUnread
        self.dontNotifyForMentionsIfMuted = dontNotifyForMentionsIfMuted
        self._wallpaper.wrappedValue = wallpaper
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.id)
        try protoWriter.encode(tag: 2, value: self.recipientId)
        try protoWriter.encode(tag: 3, value: self.archived)
        try protoWriter.encode(tag: 4, value: self.pinnedOrder)
        try protoWriter.encode(tag: 5, value: self.expirationTimerMs)
        try protoWriter.encode(tag: 6, value: self.muteUntilMs)
        try protoWriter.encode(tag: 7, value: self.markedUnread)
        try protoWriter.encode(tag: 8, value: self.dontNotifyForMentionsIfMuted)
        try protoWriter.encode(tag: 9, value: self.wallpaper)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.Chat : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.id = try container.decode(stringEncoded: UInt64.self, forKey: "id")
        self.recipientId = try container.decode(stringEncoded: UInt64.self, forKey: "recipientId")
        self.archived = try container.decode(Bool.self, forKey: "archived")
        self.pinnedOrder = try container.decode(UInt32.self, forKey: "pinnedOrder")
        self.expirationTimerMs = try container.decode(stringEncoded: UInt64.self, forKey: "expirationTimerMs")
        self.muteUntilMs = try container.decode(stringEncoded: UInt64.self, forKey: "muteUntilMs")
        self.markedUnread = try container.decode(Bool.self, forKey: "markedUnread")
        self.dontNotifyForMentionsIfMuted = try container.decode(Bool.self, forKey: "dontNotifyForMentionsIfMuted")
        self._wallpaper.wrappedValue = try container.decodeIfPresent(BackupProto.FilePointer.self, forKey: "wallpaper")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || self.id != 0 {
            try container.encode(stringEncoded: self.id, forKey: "id")
        }
        if includeDefaults || self.recipientId != 0 {
            try container.encode(stringEncoded: self.recipientId, forKey: "recipientId")
        }
        if includeDefaults || self.archived != false {
            try container.encode(self.archived, forKey: "archived")
        }
        if includeDefaults || self.pinnedOrder != 0 {
            try container.encode(self.pinnedOrder, forKey: "pinnedOrder")
        }
        if includeDefaults || self.expirationTimerMs != 0 {
            try container.encode(stringEncoded: self.expirationTimerMs, forKey: "expirationTimerMs")
        }
        if includeDefaults || self.muteUntilMs != 0 {
            try container.encode(stringEncoded: self.muteUntilMs, forKey: "muteUntilMs")
        }
        if includeDefaults || self.markedUnread != false {
            try container.encode(self.markedUnread, forKey: "markedUnread")
        }
        if includeDefaults || self.dontNotifyForMentionsIfMuted != false {
            try container.encode(self.dontNotifyForMentionsIfMuted, forKey: "dontNotifyForMentionsIfMuted")
        }
        try container.encodeIfPresent(self.wallpaper, forKey: "wallpaper")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.DistributionList : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.DistributionList : Hashable {
}
#endif

extension BackupProto.DistributionList : Sendable {
}

extension BackupProto.DistributionList : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.DistributionList"
    }

}

extension BackupProto.DistributionList : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var name: String = ""
        var distributionId: Foundation.Data = .init()
        var allowReplies: Bool = false
        var deletionTimestamp: UInt64 = 0
        var privacyMode: BackupProto.DistributionList.PrivacyMode? = nil
        var memberRecipientIds: [UInt64] = []

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: name = try protoReader.decode(String.self)
            case 2: distributionId = try protoReader.decode(Foundation.Data.self)
            case 3: allowReplies = try protoReader.decode(Bool.self)
            case 4: deletionTimestamp = try protoReader.decode(UInt64.self)
            case 5: privacyMode = try protoReader.decode(BackupProto.DistributionList.PrivacyMode.self)
            case 6: try protoReader.decode(into: &memberRecipientIds)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.name = name
        self.distributionId = distributionId
        self.allowReplies = allowReplies
        self.deletionTimestamp = deletionTimestamp
        self._privacyMode.wrappedValue = try BackupProto.DistributionList.PrivacyMode.defaultIfMissing(privacyMode)
        self.memberRecipientIds = memberRecipientIds
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.name)
        try protoWriter.encode(tag: 2, value: self.distributionId)
        try protoWriter.encode(tag: 3, value: self.allowReplies)
        try protoWriter.encode(tag: 4, value: self.deletionTimestamp)
        try protoWriter.encode(tag: 5, value: self.privacyMode)
        try protoWriter.encode(tag: 6, value: self.memberRecipientIds, packed: true)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.DistributionList : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.name = try container.decode(String.self, forKey: "name")
        self.distributionId = try container.decode(stringEncoded: Foundation.Data.self, forKey: "distributionId")
        self.allowReplies = try container.decode(Bool.self, forKey: "allowReplies")
        self.deletionTimestamp = try container.decode(stringEncoded: UInt64.self, forKey: "deletionTimestamp")
        self._privacyMode.wrappedValue = try container.decodeIfPresent(BackupProto.DistributionList.PrivacyMode.self, forKey: "privacyMode")
        self.memberRecipientIds = try container.decodeProtoArray(UInt64.self, forKey: "memberRecipientIds")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.name.isEmpty {
            try container.encode(self.name, forKey: "name")
        }
        if includeDefaults || !self.distributionId.isEmpty {
            try container.encode(stringEncoded: self.distributionId, forKey: "distributionId")
        }
        if includeDefaults || self.allowReplies != false {
            try container.encode(self.allowReplies, forKey: "allowReplies")
        }
        if includeDefaults || self.deletionTimestamp != 0 {
            try container.encode(stringEncoded: self.deletionTimestamp, forKey: "deletionTimestamp")
        }
        try container.encodeIfPresent(self.privacyMode, forKey: "privacyMode")
        if includeDefaults || !self.memberRecipientIds.isEmpty {
            try container.encodeProtoArray(self.memberRecipientIds, forKey: "memberRecipientIds")
        }
    }

}
#endif

/**
 * Subtypes within BackupProto.DistributionList
 */
extension BackupProto.DistributionList {

    public enum PrivacyMode : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN = 0
        case ONLY_WITH = 1
        case ALL_EXCEPT = 2
        case ALL = 3

        public static var defaultedValue: BackupProto.DistributionList.PrivacyMode {
            BackupProto.DistributionList.PrivacyMode.UNKNOWN
        }
        public var description: String {
            switch self {
            case .UNKNOWN: return "UNKNOWN"
            case .ONLY_WITH: return "ONLY_WITH"
            case .ALL_EXCEPT: return "ALL_EXCEPT"
            case .ALL: return "ALL"
            }
        }

    }

}

extension BackupProto.DistributionList.PrivacyMode : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Identity : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Identity : Hashable {
}
#endif

extension BackupProto.Identity : Sendable {
}

extension BackupProto.Identity : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.Identity"
    }

}

extension BackupProto.Identity : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var serviceId: Foundation.Data = .init()
        var identityKey: Foundation.Data = .init()
        var timestamp: UInt64 = 0
        var firstUse: Bool = false
        var verified: Bool = false
        var nonblockingApproval: Bool = false

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: serviceId = try protoReader.decode(Foundation.Data.self)
            case 2: identityKey = try protoReader.decode(Foundation.Data.self)
            case 3: timestamp = try protoReader.decode(UInt64.self)
            case 4: firstUse = try protoReader.decode(Bool.self)
            case 5: verified = try protoReader.decode(Bool.self)
            case 6: nonblockingApproval = try protoReader.decode(Bool.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.serviceId = serviceId
        self.identityKey = identityKey
        self.timestamp = timestamp
        self.firstUse = firstUse
        self.verified = verified
        self.nonblockingApproval = nonblockingApproval
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.serviceId)
        try protoWriter.encode(tag: 2, value: self.identityKey)
        try protoWriter.encode(tag: 3, value: self.timestamp)
        try protoWriter.encode(tag: 4, value: self.firstUse)
        try protoWriter.encode(tag: 5, value: self.verified)
        try protoWriter.encode(tag: 6, value: self.nonblockingApproval)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.Identity : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.serviceId = try container.decode(stringEncoded: Foundation.Data.self, forKey: "serviceId")
        self.identityKey = try container.decode(stringEncoded: Foundation.Data.self, forKey: "identityKey")
        self.timestamp = try container.decode(stringEncoded: UInt64.self, forKey: "timestamp")
        self.firstUse = try container.decode(Bool.self, forKey: "firstUse")
        self.verified = try container.decode(Bool.self, forKey: "verified")
        self.nonblockingApproval = try container.decode(Bool.self, forKey: "nonblockingApproval")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.serviceId.isEmpty {
            try container.encode(stringEncoded: self.serviceId, forKey: "serviceId")
        }
        if includeDefaults || !self.identityKey.isEmpty {
            try container.encode(stringEncoded: self.identityKey, forKey: "identityKey")
        }
        if includeDefaults || self.timestamp != 0 {
            try container.encode(stringEncoded: self.timestamp, forKey: "timestamp")
        }
        if includeDefaults || self.firstUse != false {
            try container.encode(self.firstUse, forKey: "firstUse")
        }
        if includeDefaults || self.verified != false {
            try container.encode(self.verified, forKey: "verified")
        }
        if includeDefaults || self.nonblockingApproval != false {
            try container.encode(self.nonblockingApproval, forKey: "nonblockingApproval")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Call : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Call : Hashable {
}
#endif

extension BackupProto.Call : Sendable {
}

extension BackupProto.Call : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.Call"
    }

}

extension BackupProto.Call : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var callId: UInt64 = 0
        var conversationRecipientId: UInt64 = 0
        var type: BackupProto.Call.Type_? = nil
        var outgoing: Bool = false
        var timestamp: UInt64 = 0
        var ringerRecipientId: UInt64? = nil
        var event: BackupProto.Call.Event? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: callId = try protoReader.decode(UInt64.self)
            case 2: conversationRecipientId = try protoReader.decode(UInt64.self)
            case 3: type = try protoReader.decode(BackupProto.Call.Type_.self)
            case 4: outgoing = try protoReader.decode(Bool.self)
            case 5: timestamp = try protoReader.decode(UInt64.self)
            case 6: ringerRecipientId = try protoReader.decode(UInt64.self)
            case 7: event = try protoReader.decode(BackupProto.Call.Event.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.callId = callId
        self.conversationRecipientId = conversationRecipientId
        self._type.wrappedValue = try BackupProto.Call.Type_.defaultIfMissing(type)
        self.outgoing = outgoing
        self.timestamp = timestamp
        self._ringerRecipientId.wrappedValue = ringerRecipientId
        self._event.wrappedValue = try BackupProto.Call.Event.defaultIfMissing(event)
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.callId)
        try protoWriter.encode(tag: 2, value: self.conversationRecipientId)
        try protoWriter.encode(tag: 3, value: self.type)
        try protoWriter.encode(tag: 4, value: self.outgoing)
        try protoWriter.encode(tag: 5, value: self.timestamp)
        try protoWriter.encode(tag: 6, value: self.ringerRecipientId)
        try protoWriter.encode(tag: 7, value: self.event)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.Call : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.callId = try container.decode(stringEncoded: UInt64.self, forKey: "callId")
        self.conversationRecipientId = try container.decode(stringEncoded: UInt64.self, forKey: "conversationRecipientId")
        self._type.wrappedValue = try container.decodeIfPresent(BackupProto.Call.Type_.self, forKey: "type")
        self.outgoing = try container.decode(Bool.self, forKey: "outgoing")
        self.timestamp = try container.decode(stringEncoded: UInt64.self, forKey: "timestamp")
        self._ringerRecipientId.wrappedValue = try container.decodeIfPresent(stringEncoded: UInt64.self, forKey: "ringerRecipientId")
        self._event.wrappedValue = try container.decodeIfPresent(BackupProto.Call.Event.self, forKey: "event")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || self.callId != 0 {
            try container.encode(stringEncoded: self.callId, forKey: "callId")
        }
        if includeDefaults || self.conversationRecipientId != 0 {
            try container.encode(stringEncoded: self.conversationRecipientId, forKey: "conversationRecipientId")
        }
        try container.encodeIfPresent(self.type, forKey: "type")
        if includeDefaults || self.outgoing != false {
            try container.encode(self.outgoing, forKey: "outgoing")
        }
        if includeDefaults || self.timestamp != 0 {
            try container.encode(stringEncoded: self.timestamp, forKey: "timestamp")
        }
        try container.encodeIfPresent(stringEncoded: self.ringerRecipientId, forKey: "ringerRecipientId")
        try container.encodeIfPresent(self.event, forKey: "event")
    }

}
#endif

/**
 * Subtypes within BackupProto.Call
 */
extension BackupProto.Call {

    public enum Type_ : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN_TYPE = 0
        case AUDIO_CALL = 1
        case VIDEO_CALL = 2
        case GROUP_CALL = 3
        case AD_HOC_CALL = 4

        public static var defaultedValue: BackupProto.Call.Type_ {
            BackupProto.Call.Type_.UNKNOWN_TYPE
        }
        public var description: String {
            switch self {
            case .UNKNOWN_TYPE: return "UNKNOWN_TYPE"
            case .AUDIO_CALL: return "AUDIO_CALL"
            case .VIDEO_CALL: return "VIDEO_CALL"
            case .GROUP_CALL: return "GROUP_CALL"
            case .AD_HOC_CALL: return "AD_HOC_CALL"
            }
        }

    }

    public enum Event : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN_EVENT = 0
        /**
         * 1:1 calls only
         */
        case OUTGOING = 1
        /**
         * 1:1 and group calls. Group calls: You accepted a ring.
         */
        case ACCEPTED = 2
        /**
         * 1:1 calls only,
         */
        case NOT_ACCEPTED = 3
        /**
         * 1:1 and group. Group calls: The remote ring has expired or was cancelled by the ringer.
         */
        case MISSED = 4
        /**
         * 1:1 and Group/Ad-Hoc Calls.
         */
        case DELETE = 5
        /**
         * Group/Ad-Hoc Calls only. Initial state
         */
        case GENERIC_GROUP_CALL = 6
        /**
         * Group Calls: User has joined the group call.
         */
        case JOINED = 7
        /**
         * Group Calls: If you declined a ring.
         */
        case DECLINED = 8
        /**
         * Group Calls: If you are ringing a group.
         */
        case OUTGOING_RING = 9

        public static var defaultedValue: BackupProto.Call.Event {
            BackupProto.Call.Event.UNKNOWN_EVENT
        }
        public var description: String {
            switch self {
            case .UNKNOWN_EVENT: return "UNKNOWN_EVENT"
            case .OUTGOING: return "OUTGOING"
            case .ACCEPTED: return "ACCEPTED"
            case .NOT_ACCEPTED: return "NOT_ACCEPTED"
            case .MISSED: return "MISSED"
            case .DELETE: return "DELETE"
            case .GENERIC_GROUP_CALL: return "GENERIC_GROUP_CALL"
            case .JOINED: return "JOINED"
            case .DECLINED: return "DECLINED"
            case .OUTGOING_RING: return "OUTGOING_RING"
            }
        }

    }

}

extension BackupProto.Call.Type_ : Sendable {
}

extension BackupProto.Call.Event : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.ChatItem : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.ChatItem : Hashable {
}
#endif

extension BackupProto.ChatItem : Sendable {
}

extension BackupProto.ChatItem : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.ChatItem"
    }

}

extension BackupProto.ChatItem : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var chatId: UInt64 = 0
        var authorId: UInt64 = 0
        var dateSent: UInt64 = 0
        var expireStartDate: UInt64? = nil
        var expiresInMs: UInt64? = nil
        var revisions: [BackupProto.ChatItem] = []
        var sms: Bool = false
        var directionalDetails: BackupProto.ChatItem.DirectionalDetails? = nil
        var item: BackupProto.ChatItem.Item? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: chatId = try protoReader.decode(UInt64.self)
            case 2: authorId = try protoReader.decode(UInt64.self)
            case 3: dateSent = try protoReader.decode(UInt64.self)
            case 4: expireStartDate = try protoReader.decode(UInt64.self)
            case 5: expiresInMs = try protoReader.decode(UInt64.self)
            case 6: try protoReader.decode(into: &revisions)
            case 7: sms = try protoReader.decode(Bool.self)
            case 8: directionalDetails = .incoming(try protoReader.decode(BackupProto.ChatItem.IncomingMessageDetails.self))
            case 9: directionalDetails = .outgoing(try protoReader.decode(BackupProto.ChatItem.OutgoingMessageDetails.self))
            case 10: directionalDetails = .directionless(try protoReader.decode(BackupProto.ChatItem.DirectionlessMessageDetails.self))
            case 11: item = .standardMessage(try protoReader.decode(BackupProto.StandardMessage.self))
            case 12: item = .contactMessage(try protoReader.decode(BackupProto.ContactMessage.self))
            case 13: item = .stickerMessage(try protoReader.decode(BackupProto.StickerMessage.self))
            case 14: item = .remoteDeletedMessage(try protoReader.decode(BackupProto.RemoteDeletedMessage.self))
            case 15: item = .updateMessage(try protoReader.decode(BackupProto.ChatUpdateMessage.self))
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.chatId = chatId
        self.authorId = authorId
        self.dateSent = dateSent
        self._expireStartDate.wrappedValue = expireStartDate
        self._expiresInMs.wrappedValue = expiresInMs
        self.revisions = revisions
        self.sms = sms
        self.directionalDetails = directionalDetails
        self.item = item
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.chatId)
        try protoWriter.encode(tag: 2, value: self.authorId)
        try protoWriter.encode(tag: 3, value: self.dateSent)
        try protoWriter.encode(tag: 4, value: self.expireStartDate)
        try protoWriter.encode(tag: 5, value: self.expiresInMs)
        try protoWriter.encode(tag: 6, value: self.revisions)
        try protoWriter.encode(tag: 7, value: self.sms)
        if let directionalDetails = self.directionalDetails {
            try directionalDetails.encode(to: protoWriter)
        }
        if let item = self.item {
            try item.encode(to: protoWriter)
        }
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.ChatItem : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.chatId = try container.decode(stringEncoded: UInt64.self, forKey: "chatId")
        self.authorId = try container.decode(stringEncoded: UInt64.self, forKey: "authorId")
        self.dateSent = try container.decode(stringEncoded: UInt64.self, forKey: "dateSent")
        self._expireStartDate.wrappedValue = try container.decodeIfPresent(stringEncoded: UInt64.self, forKey: "expireStartDate")
        self._expiresInMs.wrappedValue = try container.decodeIfPresent(stringEncoded: UInt64.self, forKey: "expiresInMs")
        self.revisions = try container.decodeProtoArray(BackupProto.ChatItem.self, forKey: "revisions")
        self.sms = try container.decode(Bool.self, forKey: "sms")
        if let incoming = try container.decodeIfPresent(BackupProto.ChatItem.IncomingMessageDetails.self, forKey: "incoming") {
            self.directionalDetails = .incoming(incoming)
        } else if let outgoing = try container.decodeIfPresent(BackupProto.ChatItem.OutgoingMessageDetails.self, forKey: "outgoing") {
            self.directionalDetails = .outgoing(outgoing)
        } else if let directionless = try container.decodeIfPresent(BackupProto.ChatItem.DirectionlessMessageDetails.self, forKey: "directionless") {
            self.directionalDetails = .directionless(directionless)
        } else {
            self.directionalDetails = nil
        }
        if let standardMessage = try container.decodeIfPresent(BackupProto.StandardMessage.self, forKey: "standardMessage") {
            self.item = .standardMessage(standardMessage)
        } else if let contactMessage = try container.decodeIfPresent(BackupProto.ContactMessage.self, forKey: "contactMessage") {
            self.item = .contactMessage(contactMessage)
        } else if let stickerMessage = try container.decodeIfPresent(BackupProto.StickerMessage.self, forKey: "stickerMessage") {
            self.item = .stickerMessage(stickerMessage)
        } else if let remoteDeletedMessage = try container.decodeIfPresent(BackupProto.RemoteDeletedMessage.self, forKey: "remoteDeletedMessage") {
            self.item = .remoteDeletedMessage(remoteDeletedMessage)
        } else if let updateMessage = try container.decodeIfPresent(BackupProto.ChatUpdateMessage.self, forKey: "updateMessage") {
            self.item = .updateMessage(updateMessage)
        } else {
            self.item = nil
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || self.chatId != 0 {
            try container.encode(stringEncoded: self.chatId, forKey: "chatId")
        }
        if includeDefaults || self.authorId != 0 {
            try container.encode(stringEncoded: self.authorId, forKey: "authorId")
        }
        if includeDefaults || self.dateSent != 0 {
            try container.encode(stringEncoded: self.dateSent, forKey: "dateSent")
        }
        try container.encodeIfPresent(stringEncoded: self.expireStartDate, forKey: "expireStartDate")
        try container.encodeIfPresent(stringEncoded: self.expiresInMs, forKey: "expiresInMs")
        if includeDefaults || !self.revisions.isEmpty {
            try container.encodeProtoArray(self.revisions, forKey: "revisions")
        }
        if includeDefaults || self.sms != false {
            try container.encode(self.sms, forKey: "sms")
        }
        switch self.directionalDetails {
        case .incoming(let incoming): try container.encode(incoming, forKey: "incoming")
        case .outgoing(let outgoing): try container.encode(outgoing, forKey: "outgoing")
        case .directionless(let directionless): try container.encode(directionless, forKey: "directionless")
        case Optional.none: break
        }
        switch self.item {
        case .standardMessage(let standardMessage): try container.encode(standardMessage, forKey: "standardMessage")
        case .contactMessage(let contactMessage): try container.encode(contactMessage, forKey: "contactMessage")
        case .stickerMessage(let stickerMessage): try container.encode(stickerMessage, forKey: "stickerMessage")
        case .remoteDeletedMessage(let remoteDeletedMessage): try container.encode(remoteDeletedMessage, forKey: "remoteDeletedMessage")
        case .updateMessage(let updateMessage): try container.encode(updateMessage, forKey: "updateMessage")
        case Optional.none: break
        }
    }

}
#endif

/**
 * Subtypes within BackupProto.ChatItem
 */
extension BackupProto.ChatItem {

    public enum DirectionalDetails {

        case incoming(BackupProto.ChatItem.IncomingMessageDetails)
        case outgoing(BackupProto.ChatItem.OutgoingMessageDetails)
        case directionless(BackupProto.ChatItem.DirectionlessMessageDetails)

        fileprivate func encode(to protoWriter: ProtoWriter) throws {
            switch self {
            case .incoming(let incoming): try protoWriter.encode(tag: 8, value: incoming)
            case .outgoing(let outgoing): try protoWriter.encode(tag: 9, value: outgoing)
            case .directionless(let directionless): try protoWriter.encode(tag: 10, value: directionless)
            }
        }

    }

    public enum Item {

        case standardMessage(BackupProto.StandardMessage)
        case contactMessage(BackupProto.ContactMessage)
        case stickerMessage(BackupProto.StickerMessage)
        case remoteDeletedMessage(BackupProto.RemoteDeletedMessage)
        case updateMessage(BackupProto.ChatUpdateMessage)

        fileprivate func encode(to protoWriter: ProtoWriter) throws {
            switch self {
            case .standardMessage(let standardMessage): try protoWriter.encode(tag: 11, value: standardMessage)
            case .contactMessage(let contactMessage): try protoWriter.encode(tag: 12, value: contactMessage)
            case .stickerMessage(let stickerMessage): try protoWriter.encode(tag: 13, value: stickerMessage)
            case .remoteDeletedMessage(let remoteDeletedMessage): try protoWriter.encode(tag: 14, value: remoteDeletedMessage)
            case .updateMessage(let updateMessage): try protoWriter.encode(tag: 15, value: updateMessage)
            }
        }

    }

    public struct IncomingMessageDetails {

        public var dateReceived: UInt64
        public var dateServerSent: UInt64
        public var read: Bool
        public var sealedSender: Bool
        public var unknownFields: UnknownFields = .init()

        public init(
            dateReceived: UInt64,
            dateServerSent: UInt64,
            read: Bool,
            sealedSender: Bool
        ) {
            self.dateReceived = dateReceived
            self.dateServerSent = dateServerSent
            self.read = read
            self.sealedSender = sealedSender
        }

    }

    public struct OutgoingMessageDetails {

        public var sendStatus: [BackupProto.SendStatus] = []
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct DirectionlessMessageDetails {

        public var unknownFields: UnknownFields = .init()

        public init() {
        }

    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.ChatItem.DirectionalDetails : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.ChatItem.DirectionalDetails : Hashable {
}
#endif

extension BackupProto.ChatItem.DirectionalDetails : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.ChatItem.Item : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.ChatItem.Item : Hashable {
}
#endif

extension BackupProto.ChatItem.Item : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.ChatItem.IncomingMessageDetails : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.ChatItem.IncomingMessageDetails : Hashable {
}
#endif

extension BackupProto.ChatItem.IncomingMessageDetails : Sendable {
}

extension BackupProto.ChatItem.IncomingMessageDetails : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.ChatItem.IncomingMessageDetails"
    }

}

extension BackupProto.ChatItem.IncomingMessageDetails : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var dateReceived: UInt64 = 0
        var dateServerSent: UInt64 = 0
        var read: Bool = false
        var sealedSender: Bool = false

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: dateReceived = try protoReader.decode(UInt64.self)
            case 2: dateServerSent = try protoReader.decode(UInt64.self)
            case 3: read = try protoReader.decode(Bool.self)
            case 4: sealedSender = try protoReader.decode(Bool.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.dateReceived = dateReceived
        self.dateServerSent = dateServerSent
        self.read = read
        self.sealedSender = sealedSender
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.dateReceived)
        try protoWriter.encode(tag: 2, value: self.dateServerSent)
        try protoWriter.encode(tag: 3, value: self.read)
        try protoWriter.encode(tag: 4, value: self.sealedSender)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.ChatItem.IncomingMessageDetails : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.dateReceived = try container.decode(stringEncoded: UInt64.self, forKey: "dateReceived")
        self.dateServerSent = try container.decode(stringEncoded: UInt64.self, forKey: "dateServerSent")
        self.read = try container.decode(Bool.self, forKey: "read")
        self.sealedSender = try container.decode(Bool.self, forKey: "sealedSender")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || self.dateReceived != 0 {
            try container.encode(stringEncoded: self.dateReceived, forKey: "dateReceived")
        }
        if includeDefaults || self.dateServerSent != 0 {
            try container.encode(stringEncoded: self.dateServerSent, forKey: "dateServerSent")
        }
        if includeDefaults || self.read != false {
            try container.encode(self.read, forKey: "read")
        }
        if includeDefaults || self.sealedSender != false {
            try container.encode(self.sealedSender, forKey: "sealedSender")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.ChatItem.OutgoingMessageDetails : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.ChatItem.OutgoingMessageDetails : Hashable {
}
#endif

extension BackupProto.ChatItem.OutgoingMessageDetails : Sendable {
}

extension BackupProto.ChatItem.OutgoingMessageDetails : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.ChatItem.OutgoingMessageDetails {
        BackupProto.ChatItem.OutgoingMessageDetails()
    }
}

extension BackupProto.ChatItem.OutgoingMessageDetails : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.ChatItem.OutgoingMessageDetails"
    }

}

extension BackupProto.ChatItem.OutgoingMessageDetails : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var sendStatus: [BackupProto.SendStatus] = []

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: try protoReader.decode(into: &sendStatus)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.sendStatus = sendStatus
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.sendStatus)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.ChatItem.OutgoingMessageDetails : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.sendStatus = try container.decodeProtoArray(BackupProto.SendStatus.self, forKey: "sendStatus")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.sendStatus.isEmpty {
            try container.encodeProtoArray(self.sendStatus, forKey: "sendStatus")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.ChatItem.DirectionlessMessageDetails : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.ChatItem.DirectionlessMessageDetails : Hashable {
}
#endif

extension BackupProto.ChatItem.DirectionlessMessageDetails : Sendable {
}

extension BackupProto.ChatItem.DirectionlessMessageDetails : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.ChatItem.DirectionlessMessageDetails {
        BackupProto.ChatItem.DirectionlessMessageDetails()
    }
}

extension BackupProto.ChatItem.DirectionlessMessageDetails : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.ChatItem.DirectionlessMessageDetails"
    }

}

extension BackupProto.ChatItem.DirectionlessMessageDetails : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.ChatItem.DirectionlessMessageDetails : Codable {

    public enum CodingKeys : CodingKey {
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.SendStatus : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.SendStatus : Hashable {
}
#endif

extension BackupProto.SendStatus : Sendable {
}

extension BackupProto.SendStatus : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.SendStatus"
    }

}

extension BackupProto.SendStatus : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var recipientId: UInt64 = 0
        var deliveryStatus: BackupProto.SendStatus.Status? = nil
        var networkFailure: Bool = false
        var identityKeyMismatch: Bool = false
        var sealedSender: Bool = false
        var lastStatusUpdateTimestamp: UInt64 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: recipientId = try protoReader.decode(UInt64.self)
            case 2: deliveryStatus = try protoReader.decode(BackupProto.SendStatus.Status.self)
            case 3: networkFailure = try protoReader.decode(Bool.self)
            case 4: identityKeyMismatch = try protoReader.decode(Bool.self)
            case 5: sealedSender = try protoReader.decode(Bool.self)
            case 6: lastStatusUpdateTimestamp = try protoReader.decode(UInt64.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.recipientId = recipientId
        self._deliveryStatus.wrappedValue = try BackupProto.SendStatus.Status.defaultIfMissing(deliveryStatus)
        self.networkFailure = networkFailure
        self.identityKeyMismatch = identityKeyMismatch
        self.sealedSender = sealedSender
        self.lastStatusUpdateTimestamp = lastStatusUpdateTimestamp
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.recipientId)
        try protoWriter.encode(tag: 2, value: self.deliveryStatus)
        try protoWriter.encode(tag: 3, value: self.networkFailure)
        try protoWriter.encode(tag: 4, value: self.identityKeyMismatch)
        try protoWriter.encode(tag: 5, value: self.sealedSender)
        try protoWriter.encode(tag: 6, value: self.lastStatusUpdateTimestamp)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.SendStatus : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.recipientId = try container.decode(stringEncoded: UInt64.self, forKey: "recipientId")
        self._deliveryStatus.wrappedValue = try container.decodeIfPresent(BackupProto.SendStatus.Status.self, forKey: "deliveryStatus")
        self.networkFailure = try container.decode(Bool.self, forKey: "networkFailure")
        self.identityKeyMismatch = try container.decode(Bool.self, forKey: "identityKeyMismatch")
        self.sealedSender = try container.decode(Bool.self, forKey: "sealedSender")
        self.lastStatusUpdateTimestamp = try container.decode(stringEncoded: UInt64.self, forKey: "lastStatusUpdateTimestamp")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || self.recipientId != 0 {
            try container.encode(stringEncoded: self.recipientId, forKey: "recipientId")
        }
        try container.encodeIfPresent(self.deliveryStatus, forKey: "deliveryStatus")
        if includeDefaults || self.networkFailure != false {
            try container.encode(self.networkFailure, forKey: "networkFailure")
        }
        if includeDefaults || self.identityKeyMismatch != false {
            try container.encode(self.identityKeyMismatch, forKey: "identityKeyMismatch")
        }
        if includeDefaults || self.sealedSender != false {
            try container.encode(self.sealedSender, forKey: "sealedSender")
        }
        if includeDefaults || self.lastStatusUpdateTimestamp != 0 {
            try container.encode(stringEncoded: self.lastStatusUpdateTimestamp, forKey: "lastStatusUpdateTimestamp")
        }
    }

}
#endif

/**
 * Subtypes within BackupProto.SendStatus
 */
extension BackupProto.SendStatus {

    public enum Status : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN = 0
        case FAILED = 1
        case PENDING = 2
        case SENT = 3
        case DELIVERED = 4
        case READ = 5
        case VIEWED = 6
        /**
         * e.g. user in group was blocked, so we skipped sending to them
         */
        case SKIPPED = 7

        public static var defaultedValue: BackupProto.SendStatus.Status {
            BackupProto.SendStatus.Status.UNKNOWN
        }
        public var description: String {
            switch self {
            case .UNKNOWN: return "UNKNOWN"
            case .FAILED: return "FAILED"
            case .PENDING: return "PENDING"
            case .SENT: return "SENT"
            case .DELIVERED: return "DELIVERED"
            case .READ: return "READ"
            case .VIEWED: return "VIEWED"
            case .SKIPPED: return "SKIPPED"
            }
        }

    }

}

extension BackupProto.SendStatus.Status : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Text : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Text : Hashable {
}
#endif

extension BackupProto.Text : Sendable {
}

extension BackupProto.Text : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.Text"
    }

}

extension BackupProto.Text : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var body: String = ""
        var bodyRanges: [BackupProto.BodyRange] = []

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: body = try protoReader.decode(String.self)
            case 2: try protoReader.decode(into: &bodyRanges)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.body = body
        self.bodyRanges = bodyRanges
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.body)
        try protoWriter.encode(tag: 2, value: self.bodyRanges)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.Text : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.body = try container.decode(String.self, forKey: "body")
        self.bodyRanges = try container.decodeProtoArray(BackupProto.BodyRange.self, forKey: "bodyRanges")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.body.isEmpty {
            try container.encode(self.body, forKey: "body")
        }
        if includeDefaults || !self.bodyRanges.isEmpty {
            try container.encodeProtoArray(self.bodyRanges, forKey: "bodyRanges")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.StandardMessage : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.StandardMessage : Hashable {
}
#endif

extension BackupProto.StandardMessage : Sendable {
}

extension BackupProto.StandardMessage : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.StandardMessage {
        BackupProto.StandardMessage()
    }
}

extension BackupProto.StandardMessage : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.StandardMessage"
    }

}

extension BackupProto.StandardMessage : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var quote: BackupProto.Quote? = nil
        var text: BackupProto.Text? = nil
        var attachments: [BackupProto.FilePointer] = []
        var linkPreview: [BackupProto.LinkPreview] = []
        var longText: BackupProto.FilePointer? = nil
        var reactions: [BackupProto.Reaction] = []

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: quote = try protoReader.decode(BackupProto.Quote.self)
            case 2: text = try protoReader.decode(BackupProto.Text.self)
            case 3: try protoReader.decode(into: &attachments)
            case 4: try protoReader.decode(into: &linkPreview)
            case 5: longText = try protoReader.decode(BackupProto.FilePointer.self)
            case 6: try protoReader.decode(into: &reactions)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.quote = quote
        self.text = text
        self.attachments = attachments
        self.linkPreview = linkPreview
        self._longText.wrappedValue = longText
        self.reactions = reactions
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.quote)
        try protoWriter.encode(tag: 2, value: self.text)
        try protoWriter.encode(tag: 3, value: self.attachments)
        try protoWriter.encode(tag: 4, value: self.linkPreview)
        try protoWriter.encode(tag: 5, value: self.longText)
        try protoWriter.encode(tag: 6, value: self.reactions)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.StandardMessage : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.quote = try container.decodeIfPresent(BackupProto.Quote.self, forKey: "quote")
        self.text = try container.decodeIfPresent(BackupProto.Text.self, forKey: "text")
        self.attachments = try container.decodeProtoArray(BackupProto.FilePointer.self, forKey: "attachments")
        self.linkPreview = try container.decodeProtoArray(BackupProto.LinkPreview.self, forKey: "linkPreview")
        self._longText.wrappedValue = try container.decodeIfPresent(BackupProto.FilePointer.self, forKey: "longText")
        self.reactions = try container.decodeProtoArray(BackupProto.Reaction.self, forKey: "reactions")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(self.quote, forKey: "quote")
        try container.encodeIfPresent(self.text, forKey: "text")
        if includeDefaults || !self.attachments.isEmpty {
            try container.encodeProtoArray(self.attachments, forKey: "attachments")
        }
        if includeDefaults || !self.linkPreview.isEmpty {
            try container.encodeProtoArray(self.linkPreview, forKey: "linkPreview")
        }
        try container.encodeIfPresent(self.longText, forKey: "longText")
        if includeDefaults || !self.reactions.isEmpty {
            try container.encodeProtoArray(self.reactions, forKey: "reactions")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.ContactMessage : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.ContactMessage : Hashable {
}
#endif

extension BackupProto.ContactMessage : Sendable {
}

extension BackupProto.ContactMessage : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.ContactMessage {
        BackupProto.ContactMessage()
    }
}

extension BackupProto.ContactMessage : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.ContactMessage"
    }

}

extension BackupProto.ContactMessage : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var contact: [BackupProto.ContactAttachment] = []
        var reactions: [BackupProto.Reaction] = []

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: try protoReader.decode(into: &contact)
            case 2: try protoReader.decode(into: &reactions)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.contact = contact
        self.reactions = reactions
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.contact)
        try protoWriter.encode(tag: 2, value: self.reactions)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.ContactMessage : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.contact = try container.decodeProtoArray(BackupProto.ContactAttachment.self, forKey: "contact")
        self.reactions = try container.decodeProtoArray(BackupProto.Reaction.self, forKey: "reactions")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.contact.isEmpty {
            try container.encodeProtoArray(self.contact, forKey: "contact")
        }
        if includeDefaults || !self.reactions.isEmpty {
            try container.encodeProtoArray(self.reactions, forKey: "reactions")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.ContactAttachment : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.ContactAttachment : Hashable {
}
#endif

extension BackupProto.ContactAttachment : Sendable {
}

extension BackupProto.ContactAttachment : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.ContactAttachment {
        BackupProto.ContactAttachment()
    }
}

extension BackupProto.ContactAttachment : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.ContactAttachment"
    }

}

extension BackupProto.ContactAttachment : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var name: BackupProto.ContactAttachment.Name? = nil
        var number: [BackupProto.ContactAttachment.Phone] = []
        var email: [BackupProto.ContactAttachment.Email] = []
        var address: [BackupProto.ContactAttachment.PostalAddress] = []
        var avatar: BackupProto.ContactAttachment.Avatar? = nil
        var organization: String? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: name = try protoReader.decode(BackupProto.ContactAttachment.Name.self)
            case 3: try protoReader.decode(into: &number)
            case 4: try protoReader.decode(into: &email)
            case 5: try protoReader.decode(into: &address)
            case 6: avatar = try protoReader.decode(BackupProto.ContactAttachment.Avatar.self)
            case 7: organization = try protoReader.decode(String.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._name.wrappedValue = name
        self.number = number
        self.email = email
        self.address = address
        self._avatar.wrappedValue = avatar
        self._organization.wrappedValue = organization
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.name)
        try protoWriter.encode(tag: 3, value: self.number)
        try protoWriter.encode(tag: 4, value: self.email)
        try protoWriter.encode(tag: 5, value: self.address)
        try protoWriter.encode(tag: 6, value: self.avatar)
        try protoWriter.encode(tag: 7, value: self.organization)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.ContactAttachment : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._name.wrappedValue = try container.decodeIfPresent(BackupProto.ContactAttachment.Name.self, forKey: "name")
        self.number = try container.decodeProtoArray(BackupProto.ContactAttachment.Phone.self, forKey: "number")
        self.email = try container.decodeProtoArray(BackupProto.ContactAttachment.Email.self, forKey: "email")
        self.address = try container.decodeProtoArray(BackupProto.ContactAttachment.PostalAddress.self, forKey: "address")
        self._avatar.wrappedValue = try container.decodeIfPresent(BackupProto.ContactAttachment.Avatar.self, forKey: "avatar")
        self._organization.wrappedValue = try container.decodeIfPresent(String.self, forKey: "organization")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(self.name, forKey: "name")
        if includeDefaults || !self.number.isEmpty {
            try container.encodeProtoArray(self.number, forKey: "number")
        }
        if includeDefaults || !self.email.isEmpty {
            try container.encodeProtoArray(self.email, forKey: "email")
        }
        if includeDefaults || !self.address.isEmpty {
            try container.encodeProtoArray(self.address, forKey: "address")
        }
        try container.encodeIfPresent(self.avatar, forKey: "avatar")
        try container.encodeIfPresent(self.organization, forKey: "organization")
    }

}
#endif

/**
 * Subtypes within BackupProto.ContactAttachment
 */
extension BackupProto.ContactAttachment {

    public struct Name {

        @ProtoDefaulted
        public var givenName: String?
        @ProtoDefaulted
        public var familyName: String?
        @ProtoDefaulted
        public var prefix: String?
        @ProtoDefaulted
        public var suffix: String?
        @ProtoDefaulted
        public var middleName: String?
        @ProtoDefaulted
        public var displayName: String?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct Phone {

        @ProtoDefaulted
        public var value: String?
        @ProtoDefaulted
        public var type: BackupProto.ContactAttachment.Phone.Type_?
        @ProtoDefaulted
        public var label: String?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct Email {

        @ProtoDefaulted
        public var value: String?
        @ProtoDefaulted
        public var type: BackupProto.ContactAttachment.Email.Type_?
        @ProtoDefaulted
        public var label: String?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct PostalAddress {

        @ProtoDefaulted
        public var type: BackupProto.ContactAttachment.PostalAddress.Type_?
        @ProtoDefaulted
        public var label: String?
        @ProtoDefaulted
        public var street: String?
        @ProtoDefaulted
        public var pobox: String?
        @ProtoDefaulted
        public var neighborhood: String?
        @ProtoDefaulted
        public var city: String?
        @ProtoDefaulted
        public var region: String?
        @ProtoDefaulted
        public var postcode: String?
        @ProtoDefaulted
        public var country: String?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

    public struct Avatar {

        @ProtoDefaulted
        public var avatar: BackupProto.FilePointer?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.ContactAttachment.Name : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.ContactAttachment.Name : Hashable {
}
#endif

extension BackupProto.ContactAttachment.Name : Sendable {
}

extension BackupProto.ContactAttachment.Name : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.ContactAttachment.Name {
        BackupProto.ContactAttachment.Name()
    }
}

extension BackupProto.ContactAttachment.Name : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.ContactAttachment.Name"
    }

}

extension BackupProto.ContactAttachment.Name : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var givenName: String? = nil
        var familyName: String? = nil
        var prefix: String? = nil
        var suffix: String? = nil
        var middleName: String? = nil
        var displayName: String? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: givenName = try protoReader.decode(String.self)
            case 2: familyName = try protoReader.decode(String.self)
            case 3: prefix = try protoReader.decode(String.self)
            case 4: suffix = try protoReader.decode(String.self)
            case 5: middleName = try protoReader.decode(String.self)
            case 6: displayName = try protoReader.decode(String.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._givenName.wrappedValue = givenName
        self._familyName.wrappedValue = familyName
        self._prefix.wrappedValue = prefix
        self._suffix.wrappedValue = suffix
        self._middleName.wrappedValue = middleName
        self._displayName.wrappedValue = displayName
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.givenName)
        try protoWriter.encode(tag: 2, value: self.familyName)
        try protoWriter.encode(tag: 3, value: self.prefix)
        try protoWriter.encode(tag: 4, value: self.suffix)
        try protoWriter.encode(tag: 5, value: self.middleName)
        try protoWriter.encode(tag: 6, value: self.displayName)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.ContactAttachment.Name : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._givenName.wrappedValue = try container.decodeIfPresent(String.self, forKey: "givenName")
        self._familyName.wrappedValue = try container.decodeIfPresent(String.self, forKey: "familyName")
        self._prefix.wrappedValue = try container.decodeIfPresent(String.self, forKey: "prefix")
        self._suffix.wrappedValue = try container.decodeIfPresent(String.self, forKey: "suffix")
        self._middleName.wrappedValue = try container.decodeIfPresent(String.self, forKey: "middleName")
        self._displayName.wrappedValue = try container.decodeIfPresent(String.self, forKey: "displayName")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(self.givenName, forKey: "givenName")
        try container.encodeIfPresent(self.familyName, forKey: "familyName")
        try container.encodeIfPresent(self.prefix, forKey: "prefix")
        try container.encodeIfPresent(self.suffix, forKey: "suffix")
        try container.encodeIfPresent(self.middleName, forKey: "middleName")
        try container.encodeIfPresent(self.displayName, forKey: "displayName")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.ContactAttachment.Phone : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.ContactAttachment.Phone : Hashable {
}
#endif

extension BackupProto.ContactAttachment.Phone : Sendable {
}

extension BackupProto.ContactAttachment.Phone : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.ContactAttachment.Phone {
        BackupProto.ContactAttachment.Phone()
    }
}

extension BackupProto.ContactAttachment.Phone : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.ContactAttachment.Phone"
    }

}

extension BackupProto.ContactAttachment.Phone : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var value: String? = nil
        var type: BackupProto.ContactAttachment.Phone.Type_? = nil
        var label: String? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: value = try protoReader.decode(String.self)
            case 2: type = try protoReader.decode(BackupProto.ContactAttachment.Phone.Type_.self)
            case 3: label = try protoReader.decode(String.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._value.wrappedValue = value
        self._type.wrappedValue = try BackupProto.ContactAttachment.Phone.Type_.defaultIfMissing(type)
        self._label.wrappedValue = label
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.value)
        try protoWriter.encode(tag: 2, value: self.type)
        try protoWriter.encode(tag: 3, value: self.label)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.ContactAttachment.Phone : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._value.wrappedValue = try container.decodeIfPresent(String.self, forKey: "value")
        self._type.wrappedValue = try container.decodeIfPresent(BackupProto.ContactAttachment.Phone.Type_.self, forKey: "type")
        self._label.wrappedValue = try container.decodeIfPresent(String.self, forKey: "label")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(self.value, forKey: "value")
        try container.encodeIfPresent(self.type, forKey: "type")
        try container.encodeIfPresent(self.label, forKey: "label")
    }

}
#endif

/**
 * Subtypes within BackupProto.ContactAttachment.Phone
 */
extension BackupProto.ContactAttachment.Phone {

    public enum Type_ : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN = 0
        case HOME = 1
        case MOBILE = 2
        case WORK = 3
        case CUSTOM = 4

        public static var defaultedValue: BackupProto.ContactAttachment.Phone.Type_ {
            BackupProto.ContactAttachment.Phone.Type_.UNKNOWN
        }
        public var description: String {
            switch self {
            case .UNKNOWN: return "UNKNOWN"
            case .HOME: return "HOME"
            case .MOBILE: return "MOBILE"
            case .WORK: return "WORK"
            case .CUSTOM: return "CUSTOM"
            }
        }

    }

}

extension BackupProto.ContactAttachment.Phone.Type_ : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.ContactAttachment.Email : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.ContactAttachment.Email : Hashable {
}
#endif

extension BackupProto.ContactAttachment.Email : Sendable {
}

extension BackupProto.ContactAttachment.Email : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.ContactAttachment.Email {
        BackupProto.ContactAttachment.Email()
    }
}

extension BackupProto.ContactAttachment.Email : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.ContactAttachment.Email"
    }

}

extension BackupProto.ContactAttachment.Email : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var value: String? = nil
        var type: BackupProto.ContactAttachment.Email.Type_? = nil
        var label: String? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: value = try protoReader.decode(String.self)
            case 2: type = try protoReader.decode(BackupProto.ContactAttachment.Email.Type_.self)
            case 3: label = try protoReader.decode(String.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._value.wrappedValue = value
        self._type.wrappedValue = try BackupProto.ContactAttachment.Email.Type_.defaultIfMissing(type)
        self._label.wrappedValue = label
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.value)
        try protoWriter.encode(tag: 2, value: self.type)
        try protoWriter.encode(tag: 3, value: self.label)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.ContactAttachment.Email : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._value.wrappedValue = try container.decodeIfPresent(String.self, forKey: "value")
        self._type.wrappedValue = try container.decodeIfPresent(BackupProto.ContactAttachment.Email.Type_.self, forKey: "type")
        self._label.wrappedValue = try container.decodeIfPresent(String.self, forKey: "label")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(self.value, forKey: "value")
        try container.encodeIfPresent(self.type, forKey: "type")
        try container.encodeIfPresent(self.label, forKey: "label")
    }

}
#endif

/**
 * Subtypes within BackupProto.ContactAttachment.Email
 */
extension BackupProto.ContactAttachment.Email {

    public enum Type_ : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN = 0
        case HOME = 1
        case MOBILE = 2
        case WORK = 3
        case CUSTOM = 4

        public static var defaultedValue: BackupProto.ContactAttachment.Email.Type_ {
            BackupProto.ContactAttachment.Email.Type_.UNKNOWN
        }
        public var description: String {
            switch self {
            case .UNKNOWN: return "UNKNOWN"
            case .HOME: return "HOME"
            case .MOBILE: return "MOBILE"
            case .WORK: return "WORK"
            case .CUSTOM: return "CUSTOM"
            }
        }

    }

}

extension BackupProto.ContactAttachment.Email.Type_ : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.ContactAttachment.PostalAddress : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.ContactAttachment.PostalAddress : Hashable {
}
#endif

extension BackupProto.ContactAttachment.PostalAddress : Sendable {
}

extension BackupProto.ContactAttachment.PostalAddress : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.ContactAttachment.PostalAddress {
        BackupProto.ContactAttachment.PostalAddress()
    }
}

extension BackupProto.ContactAttachment.PostalAddress : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.ContactAttachment.PostalAddress"
    }

}

extension BackupProto.ContactAttachment.PostalAddress : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var type: BackupProto.ContactAttachment.PostalAddress.Type_? = nil
        var label: String? = nil
        var street: String? = nil
        var pobox: String? = nil
        var neighborhood: String? = nil
        var city: String? = nil
        var region: String? = nil
        var postcode: String? = nil
        var country: String? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: type = try protoReader.decode(BackupProto.ContactAttachment.PostalAddress.Type_.self)
            case 2: label = try protoReader.decode(String.self)
            case 3: street = try protoReader.decode(String.self)
            case 4: pobox = try protoReader.decode(String.self)
            case 5: neighborhood = try protoReader.decode(String.self)
            case 6: city = try protoReader.decode(String.self)
            case 7: region = try protoReader.decode(String.self)
            case 8: postcode = try protoReader.decode(String.self)
            case 9: country = try protoReader.decode(String.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._type.wrappedValue = try BackupProto.ContactAttachment.PostalAddress.Type_.defaultIfMissing(type)
        self._label.wrappedValue = label
        self._street.wrappedValue = street
        self._pobox.wrappedValue = pobox
        self._neighborhood.wrappedValue = neighborhood
        self._city.wrappedValue = city
        self._region.wrappedValue = region
        self._postcode.wrappedValue = postcode
        self._country.wrappedValue = country
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.type)
        try protoWriter.encode(tag: 2, value: self.label)
        try protoWriter.encode(tag: 3, value: self.street)
        try protoWriter.encode(tag: 4, value: self.pobox)
        try protoWriter.encode(tag: 5, value: self.neighborhood)
        try protoWriter.encode(tag: 6, value: self.city)
        try protoWriter.encode(tag: 7, value: self.region)
        try protoWriter.encode(tag: 8, value: self.postcode)
        try protoWriter.encode(tag: 9, value: self.country)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.ContactAttachment.PostalAddress : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._type.wrappedValue = try container.decodeIfPresent(BackupProto.ContactAttachment.PostalAddress.Type_.self, forKey: "type")
        self._label.wrappedValue = try container.decodeIfPresent(String.self, forKey: "label")
        self._street.wrappedValue = try container.decodeIfPresent(String.self, forKey: "street")
        self._pobox.wrappedValue = try container.decodeIfPresent(String.self, forKey: "pobox")
        self._neighborhood.wrappedValue = try container.decodeIfPresent(String.self, forKey: "neighborhood")
        self._city.wrappedValue = try container.decodeIfPresent(String.self, forKey: "city")
        self._region.wrappedValue = try container.decodeIfPresent(String.self, forKey: "region")
        self._postcode.wrappedValue = try container.decodeIfPresent(String.self, forKey: "postcode")
        self._country.wrappedValue = try container.decodeIfPresent(String.self, forKey: "country")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(self.type, forKey: "type")
        try container.encodeIfPresent(self.label, forKey: "label")
        try container.encodeIfPresent(self.street, forKey: "street")
        try container.encodeIfPresent(self.pobox, forKey: "pobox")
        try container.encodeIfPresent(self.neighborhood, forKey: "neighborhood")
        try container.encodeIfPresent(self.city, forKey: "city")
        try container.encodeIfPresent(self.region, forKey: "region")
        try container.encodeIfPresent(self.postcode, forKey: "postcode")
        try container.encodeIfPresent(self.country, forKey: "country")
    }

}
#endif

/**
 * Subtypes within BackupProto.ContactAttachment.PostalAddress
 */
extension BackupProto.ContactAttachment.PostalAddress {

    public enum Type_ : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN = 0
        case HOME = 1
        case WORK = 2
        case CUSTOM = 3

        public static var defaultedValue: BackupProto.ContactAttachment.PostalAddress.Type_ {
            BackupProto.ContactAttachment.PostalAddress.Type_.UNKNOWN
        }
        public var description: String {
            switch self {
            case .UNKNOWN: return "UNKNOWN"
            case .HOME: return "HOME"
            case .WORK: return "WORK"
            case .CUSTOM: return "CUSTOM"
            }
        }

    }

}

extension BackupProto.ContactAttachment.PostalAddress.Type_ : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.ContactAttachment.Avatar : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.ContactAttachment.Avatar : Hashable {
}
#endif

extension BackupProto.ContactAttachment.Avatar : Sendable {
}

extension BackupProto.ContactAttachment.Avatar : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.ContactAttachment.Avatar {
        BackupProto.ContactAttachment.Avatar()
    }
}

extension BackupProto.ContactAttachment.Avatar : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.ContactAttachment.Avatar"
    }

}

extension BackupProto.ContactAttachment.Avatar : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var avatar: BackupProto.FilePointer? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: avatar = try protoReader.decode(BackupProto.FilePointer.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._avatar.wrappedValue = avatar
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.avatar)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.ContactAttachment.Avatar : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._avatar.wrappedValue = try container.decodeIfPresent(BackupProto.FilePointer.self, forKey: "avatar")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(self.avatar, forKey: "avatar")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.DocumentMessage : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.DocumentMessage : Hashable {
}
#endif

extension BackupProto.DocumentMessage : Sendable {
}

extension BackupProto.DocumentMessage : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.DocumentMessage {
        BackupProto.DocumentMessage()
    }
}

extension BackupProto.DocumentMessage : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.DocumentMessage"
    }

}

extension BackupProto.DocumentMessage : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var text: BackupProto.Text? = nil
        var document: BackupProto.FilePointer? = nil
        var reactions: [BackupProto.Reaction] = []

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: text = try protoReader.decode(BackupProto.Text.self)
            case 2: document = try protoReader.decode(BackupProto.FilePointer.self)
            case 3: try protoReader.decode(into: &reactions)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.text = text
        self._document.wrappedValue = document
        self.reactions = reactions
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.text)
        try protoWriter.encode(tag: 2, value: self.document)
        try protoWriter.encode(tag: 3, value: self.reactions)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.DocumentMessage : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.text = try container.decodeIfPresent(BackupProto.Text.self, forKey: "text")
        self._document.wrappedValue = try container.decodeIfPresent(BackupProto.FilePointer.self, forKey: "document")
        self.reactions = try container.decodeProtoArray(BackupProto.Reaction.self, forKey: "reactions")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(self.text, forKey: "text")
        try container.encodeIfPresent(self.document, forKey: "document")
        if includeDefaults || !self.reactions.isEmpty {
            try container.encodeProtoArray(self.reactions, forKey: "reactions")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.VoiceMessage : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.VoiceMessage : Hashable {
}
#endif

extension BackupProto.VoiceMessage : Sendable {
}

extension BackupProto.VoiceMessage : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.VoiceMessage {
        BackupProto.VoiceMessage()
    }
}

extension BackupProto.VoiceMessage : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.VoiceMessage"
    }

}

extension BackupProto.VoiceMessage : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var quote: BackupProto.Quote? = nil
        var audio: BackupProto.FilePointer? = nil
        var reactions: [BackupProto.Reaction] = []

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: quote = try protoReader.decode(BackupProto.Quote.self)
            case 2: audio = try protoReader.decode(BackupProto.FilePointer.self)
            case 3: try protoReader.decode(into: &reactions)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.quote = quote
        self._audio.wrappedValue = audio
        self.reactions = reactions
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.quote)
        try protoWriter.encode(tag: 2, value: self.audio)
        try protoWriter.encode(tag: 3, value: self.reactions)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.VoiceMessage : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.quote = try container.decodeIfPresent(BackupProto.Quote.self, forKey: "quote")
        self._audio.wrappedValue = try container.decodeIfPresent(BackupProto.FilePointer.self, forKey: "audio")
        self.reactions = try container.decodeProtoArray(BackupProto.Reaction.self, forKey: "reactions")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(self.quote, forKey: "quote")
        try container.encodeIfPresent(self.audio, forKey: "audio")
        if includeDefaults || !self.reactions.isEmpty {
            try container.encodeProtoArray(self.reactions, forKey: "reactions")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.StickerMessage : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.StickerMessage : Hashable {
}
#endif

extension BackupProto.StickerMessage : Sendable {
}

extension BackupProto.StickerMessage : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.StickerMessage {
        BackupProto.StickerMessage()
    }
}

extension BackupProto.StickerMessage : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.StickerMessage"
    }

}

extension BackupProto.StickerMessage : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var sticker: BackupProto.Sticker? = nil
        var reactions: [BackupProto.Reaction] = []

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: sticker = try protoReader.decode(BackupProto.Sticker.self)
            case 2: try protoReader.decode(into: &reactions)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.sticker = sticker
        self.reactions = reactions
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.sticker)
        try protoWriter.encode(tag: 2, value: self.reactions)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.StickerMessage : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.sticker = try container.decodeIfPresent(BackupProto.Sticker.self, forKey: "sticker")
        self.reactions = try container.decodeProtoArray(BackupProto.Reaction.self, forKey: "reactions")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(self.sticker, forKey: "sticker")
        if includeDefaults || !self.reactions.isEmpty {
            try container.encodeProtoArray(self.reactions, forKey: "reactions")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.RemoteDeletedMessage : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.RemoteDeletedMessage : Hashable {
}
#endif

extension BackupProto.RemoteDeletedMessage : Sendable {
}

extension BackupProto.RemoteDeletedMessage : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.RemoteDeletedMessage {
        BackupProto.RemoteDeletedMessage()
    }
}

extension BackupProto.RemoteDeletedMessage : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.RemoteDeletedMessage"
    }

}

extension BackupProto.RemoteDeletedMessage : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.RemoteDeletedMessage : Codable {

    public enum CodingKeys : CodingKey {
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Sticker : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Sticker : Hashable {
}
#endif

extension BackupProto.Sticker : Sendable {
}

extension BackupProto.Sticker : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.Sticker"
    }

}

extension BackupProto.Sticker : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var packId: Foundation.Data = .init()
        var packKey: Foundation.Data = .init()
        var stickerId: UInt32 = 0
        var emoji: String? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: packId = try protoReader.decode(Foundation.Data.self)
            case 2: packKey = try protoReader.decode(Foundation.Data.self)
            case 3: stickerId = try protoReader.decode(UInt32.self)
            case 4: emoji = try protoReader.decode(String.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.packId = packId
        self.packKey = packKey
        self.stickerId = stickerId
        self._emoji.wrappedValue = emoji
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.packId)
        try protoWriter.encode(tag: 2, value: self.packKey)
        try protoWriter.encode(tag: 3, value: self.stickerId)
        try protoWriter.encode(tag: 4, value: self.emoji)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.Sticker : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.packId = try container.decode(stringEncoded: Foundation.Data.self, forKey: "packId")
        self.packKey = try container.decode(stringEncoded: Foundation.Data.self, forKey: "packKey")
        self.stickerId = try container.decode(UInt32.self, forKey: "stickerId")
        self._emoji.wrappedValue = try container.decodeIfPresent(String.self, forKey: "emoji")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.packId.isEmpty {
            try container.encode(stringEncoded: self.packId, forKey: "packId")
        }
        if includeDefaults || !self.packKey.isEmpty {
            try container.encode(stringEncoded: self.packKey, forKey: "packKey")
        }
        if includeDefaults || self.stickerId != 0 {
            try container.encode(self.stickerId, forKey: "stickerId")
        }
        try container.encodeIfPresent(self.emoji, forKey: "emoji")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.LinkPreview : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.LinkPreview : Hashable {
}
#endif

extension BackupProto.LinkPreview : Sendable {
}

extension BackupProto.LinkPreview : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.LinkPreview"
    }

}

extension BackupProto.LinkPreview : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var url: String = ""
        var title: String? = nil
        var image: BackupProto.FilePointer? = nil
        var description_: String? = nil
        var date: UInt64? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: url = try protoReader.decode(String.self)
            case 2: title = try protoReader.decode(String.self)
            case 3: image = try protoReader.decode(BackupProto.FilePointer.self)
            case 4: description_ = try protoReader.decode(String.self)
            case 5: date = try protoReader.decode(UInt64.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.url = url
        self._title.wrappedValue = title
        self._image.wrappedValue = image
        self._description_.wrappedValue = description_
        self._date.wrappedValue = date
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.url)
        try protoWriter.encode(tag: 2, value: self.title)
        try protoWriter.encode(tag: 3, value: self.image)
        try protoWriter.encode(tag: 4, value: self.description_)
        try protoWriter.encode(tag: 5, value: self.date)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.LinkPreview : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.url = try container.decode(String.self, forKey: "url")
        self._title.wrappedValue = try container.decodeIfPresent(String.self, forKey: "title")
        self._image.wrappedValue = try container.decodeIfPresent(BackupProto.FilePointer.self, forKey: "image")
        self._description_.wrappedValue = try container.decodeIfPresent(String.self, forKey: "description")
        self._date.wrappedValue = try container.decodeIfPresent(stringEncoded: UInt64.self, forKey: "date")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.url.isEmpty {
            try container.encode(self.url, forKey: "url")
        }
        try container.encodeIfPresent(self.title, forKey: "title")
        try container.encodeIfPresent(self.image, forKey: "image")
        try container.encodeIfPresent(self.description_, forKey: "description")
        try container.encodeIfPresent(stringEncoded: self.date, forKey: "date")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.FilePointer : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.FilePointer : Hashable {
}
#endif

extension BackupProto.FilePointer : Sendable {
}

extension BackupProto.FilePointer : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.FilePointer {
        BackupProto.FilePointer()
    }
}

extension BackupProto.FilePointer : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.FilePointer"
    }

}

extension BackupProto.FilePointer : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var key: Foundation.Data? = nil
        var contentType: String? = nil
        var size: UInt32? = nil
        var incrementalMac: Foundation.Data? = nil
        var incrementalMacChunkSize: Foundation.Data? = nil
        var fileName: String? = nil
        var flags: UInt32? = nil
        var width: UInt32? = nil
        var height: UInt32? = nil
        var caption: String? = nil
        var blurHash: String? = nil
        var locator: BackupProto.FilePointer.Locator? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 5: key = try protoReader.decode(Foundation.Data.self)
            case 6: contentType = try protoReader.decode(String.self)
            case 7: size = try protoReader.decode(UInt32.self)
            case 8: incrementalMac = try protoReader.decode(Foundation.Data.self)
            case 9: incrementalMacChunkSize = try protoReader.decode(Foundation.Data.self)
            case 10: fileName = try protoReader.decode(String.self)
            case 11: flags = try protoReader.decode(UInt32.self)
            case 12: width = try protoReader.decode(UInt32.self)
            case 13: height = try protoReader.decode(UInt32.self)
            case 14: caption = try protoReader.decode(String.self)
            case 15: blurHash = try protoReader.decode(String.self)
            case 1: locator = .backupLocator(try protoReader.decode(BackupProto.FilePointer.BackupLocator.self))
            case 2: locator = .attachmentLocator(try protoReader.decode(BackupProto.FilePointer.AttachmentLocator.self))
            case 3: locator = .legacyAttachmentLocator(try protoReader.decode(BackupProto.FilePointer.LegacyAttachmentLocator.self))
            case 4: locator = .undownloadedBackupLocator(try protoReader.decode(BackupProto.FilePointer.UndownloadedBackupLocator.self))
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._key.wrappedValue = key
        self._contentType.wrappedValue = contentType
        self._size.wrappedValue = size
        self._incrementalMac.wrappedValue = incrementalMac
        self._incrementalMacChunkSize.wrappedValue = incrementalMacChunkSize
        self._fileName.wrappedValue = fileName
        self._flags.wrappedValue = flags
        self._width.wrappedValue = width
        self._height.wrappedValue = height
        self._caption.wrappedValue = caption
        self._blurHash.wrappedValue = blurHash
        self.locator = locator
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 5, value: self.key)
        try protoWriter.encode(tag: 6, value: self.contentType)
        try protoWriter.encode(tag: 7, value: self.size)
        try protoWriter.encode(tag: 8, value: self.incrementalMac)
        try protoWriter.encode(tag: 9, value: self.incrementalMacChunkSize)
        try protoWriter.encode(tag: 10, value: self.fileName)
        try protoWriter.encode(tag: 11, value: self.flags)
        try protoWriter.encode(tag: 12, value: self.width)
        try protoWriter.encode(tag: 13, value: self.height)
        try protoWriter.encode(tag: 14, value: self.caption)
        try protoWriter.encode(tag: 15, value: self.blurHash)
        if let locator = self.locator {
            try locator.encode(to: protoWriter)
        }
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.FilePointer : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._key.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "key")
        self._contentType.wrappedValue = try container.decodeIfPresent(String.self, forKey: "contentType")
        self._size.wrappedValue = try container.decodeIfPresent(UInt32.self, forKey: "size")
        self._incrementalMac.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "incrementalMac")
        self._incrementalMacChunkSize.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "incrementalMacChunkSize")
        self._fileName.wrappedValue = try container.decodeIfPresent(String.self, forKey: "fileName")
        self._flags.wrappedValue = try container.decodeIfPresent(UInt32.self, forKey: "flags")
        self._width.wrappedValue = try container.decodeIfPresent(UInt32.self, forKey: "width")
        self._height.wrappedValue = try container.decodeIfPresent(UInt32.self, forKey: "height")
        self._caption.wrappedValue = try container.decodeIfPresent(String.self, forKey: "caption")
        self._blurHash.wrappedValue = try container.decodeIfPresent(String.self, forKey: "blurHash")
        if let backupLocator = try container.decodeIfPresent(BackupProto.FilePointer.BackupLocator.self, forKey: "backupLocator") {
            self.locator = .backupLocator(backupLocator)
        } else if let attachmentLocator = try container.decodeIfPresent(BackupProto.FilePointer.AttachmentLocator.self, forKey: "attachmentLocator") {
            self.locator = .attachmentLocator(attachmentLocator)
        } else if let legacyAttachmentLocator = try container.decodeIfPresent(BackupProto.FilePointer.LegacyAttachmentLocator.self, forKey: "legacyAttachmentLocator") {
            self.locator = .legacyAttachmentLocator(legacyAttachmentLocator)
        } else if let undownloadedBackupLocator = try container.decodeIfPresent(BackupProto.FilePointer.UndownloadedBackupLocator.self, forKey: "undownloadedBackupLocator") {
            self.locator = .undownloadedBackupLocator(undownloadedBackupLocator)
        } else {
            self.locator = nil
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(stringEncoded: self.key, forKey: "key")
        try container.encodeIfPresent(self.contentType, forKey: "contentType")
        try container.encodeIfPresent(self.size, forKey: "size")
        try container.encodeIfPresent(stringEncoded: self.incrementalMac, forKey: "incrementalMac")
        try container.encodeIfPresent(stringEncoded: self.incrementalMacChunkSize, forKey: "incrementalMacChunkSize")
        try container.encodeIfPresent(self.fileName, forKey: "fileName")
        try container.encodeIfPresent(self.flags, forKey: "flags")
        try container.encodeIfPresent(self.width, forKey: "width")
        try container.encodeIfPresent(self.height, forKey: "height")
        try container.encodeIfPresent(self.caption, forKey: "caption")
        try container.encodeIfPresent(self.blurHash, forKey: "blurHash")
        switch self.locator {
        case .backupLocator(let backupLocator): try container.encode(backupLocator, forKey: "backupLocator")
        case .attachmentLocator(let attachmentLocator): try container.encode(attachmentLocator, forKey: "attachmentLocator")
        case .legacyAttachmentLocator(let legacyAttachmentLocator): try container.encode(legacyAttachmentLocator, forKey: "legacyAttachmentLocator")
        case .undownloadedBackupLocator(let undownloadedBackupLocator): try container.encode(undownloadedBackupLocator, forKey: "undownloadedBackupLocator")
        case Optional.none: break
        }
    }

}
#endif

/**
 * Subtypes within BackupProto.FilePointer
 */
extension BackupProto.FilePointer {

    public enum Locator {

        case backupLocator(BackupProto.FilePointer.BackupLocator)
        case attachmentLocator(BackupProto.FilePointer.AttachmentLocator)
        case legacyAttachmentLocator(BackupProto.FilePointer.LegacyAttachmentLocator)
        case undownloadedBackupLocator(BackupProto.FilePointer.UndownloadedBackupLocator)

        fileprivate func encode(to protoWriter: ProtoWriter) throws {
            switch self {
            case .backupLocator(let backupLocator): try protoWriter.encode(tag: 1, value: backupLocator)
            case .attachmentLocator(let attachmentLocator): try protoWriter.encode(tag: 2, value: attachmentLocator)
            case .legacyAttachmentLocator(let legacyAttachmentLocator): try protoWriter.encode(tag: 3, value: legacyAttachmentLocator)
            case .undownloadedBackupLocator(let undownloadedBackupLocator): try protoWriter.encode(tag: 4, value: undownloadedBackupLocator)
            }
        }

    }

    public struct BackupLocator {

        public var mediaName: String
        public var cdnNumber: UInt32
        public var unknownFields: UnknownFields = .init()

        public init(mediaName: String, cdnNumber: UInt32) {
            self.mediaName = mediaName
            self.cdnNumber = cdnNumber
        }

    }

    public struct AttachmentLocator {

        public var cdnKey: String
        public var cdnNumber: UInt32
        public var uploadTimestamp: UInt64
        public var unknownFields: UnknownFields = .init()

        public init(
            cdnKey: String,
            cdnNumber: UInt32,
            uploadTimestamp: UInt64
        ) {
            self.cdnKey = cdnKey
            self.cdnNumber = cdnNumber
            self.uploadTimestamp = uploadTimestamp
        }

    }

    public struct LegacyAttachmentLocator {

        public var cdnId: UInt64
        public var unknownFields: UnknownFields = .init()

        public init(cdnId: UInt64) {
            self.cdnId = cdnId
        }

    }

    /**
     * An attachment that was backed up without being downloaded.
     * Its MediaName should be generated as “{sender_aci}_{cdn_attachment_key}”,
     * but should eventually transition to a BackupLocator with mediaName
     * being the content hash once it is downloaded.
     */
    public struct UndownloadedBackupLocator {

        public var senderAci: Foundation.Data
        public var cdnKey: String
        public var cdnNumber: UInt32
        public var unknownFields: UnknownFields = .init()

        public init(
            senderAci: Foundation.Data,
            cdnKey: String,
            cdnNumber: UInt32
        ) {
            self.senderAci = senderAci
            self.cdnKey = cdnKey
            self.cdnNumber = cdnNumber
        }

    }

    public enum Flags : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case VOICE_MESSAGE = 0
        case BORDERLESS = 1
        case GIF = 2

        public static var defaultedValue: BackupProto.FilePointer.Flags {
            BackupProto.FilePointer.Flags.VOICE_MESSAGE
        }
        public var description: String {
            switch self {
            case .VOICE_MESSAGE: return "VOICE_MESSAGE"
            case .BORDERLESS: return "BORDERLESS"
            case .GIF: return "GIF"
            }
        }

    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.FilePointer.Locator : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.FilePointer.Locator : Hashable {
}
#endif

extension BackupProto.FilePointer.Locator : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.FilePointer.BackupLocator : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.FilePointer.BackupLocator : Hashable {
}
#endif

extension BackupProto.FilePointer.BackupLocator : Sendable {
}

extension BackupProto.FilePointer.BackupLocator : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.FilePointer.BackupLocator"
    }

}

extension BackupProto.FilePointer.BackupLocator : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var mediaName: String = ""
        var cdnNumber: UInt32 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: mediaName = try protoReader.decode(String.self)
            case 2: cdnNumber = try protoReader.decode(UInt32.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.mediaName = mediaName
        self.cdnNumber = cdnNumber
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.mediaName)
        try protoWriter.encode(tag: 2, value: self.cdnNumber)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.FilePointer.BackupLocator : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.mediaName = try container.decode(String.self, forKey: "mediaName")
        self.cdnNumber = try container.decode(UInt32.self, forKey: "cdnNumber")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.mediaName.isEmpty {
            try container.encode(self.mediaName, forKey: "mediaName")
        }
        if includeDefaults || self.cdnNumber != 0 {
            try container.encode(self.cdnNumber, forKey: "cdnNumber")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.FilePointer.AttachmentLocator : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.FilePointer.AttachmentLocator : Hashable {
}
#endif

extension BackupProto.FilePointer.AttachmentLocator : Sendable {
}

extension BackupProto.FilePointer.AttachmentLocator : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.FilePointer.AttachmentLocator"
    }

}

extension BackupProto.FilePointer.AttachmentLocator : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var cdnKey: String = ""
        var cdnNumber: UInt32 = 0
        var uploadTimestamp: UInt64 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: cdnKey = try protoReader.decode(String.self)
            case 2: cdnNumber = try protoReader.decode(UInt32.self)
            case 3: uploadTimestamp = try protoReader.decode(UInt64.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.cdnKey = cdnKey
        self.cdnNumber = cdnNumber
        self.uploadTimestamp = uploadTimestamp
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.cdnKey)
        try protoWriter.encode(tag: 2, value: self.cdnNumber)
        try protoWriter.encode(tag: 3, value: self.uploadTimestamp)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.FilePointer.AttachmentLocator : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.cdnKey = try container.decode(String.self, forKey: "cdnKey")
        self.cdnNumber = try container.decode(UInt32.self, forKey: "cdnNumber")
        self.uploadTimestamp = try container.decode(stringEncoded: UInt64.self, forKey: "uploadTimestamp")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.cdnKey.isEmpty {
            try container.encode(self.cdnKey, forKey: "cdnKey")
        }
        if includeDefaults || self.cdnNumber != 0 {
            try container.encode(self.cdnNumber, forKey: "cdnNumber")
        }
        if includeDefaults || self.uploadTimestamp != 0 {
            try container.encode(stringEncoded: self.uploadTimestamp, forKey: "uploadTimestamp")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.FilePointer.LegacyAttachmentLocator : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.FilePointer.LegacyAttachmentLocator : Hashable {
}
#endif

extension BackupProto.FilePointer.LegacyAttachmentLocator : Sendable {
}

extension BackupProto.FilePointer.LegacyAttachmentLocator : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.FilePointer.LegacyAttachmentLocator"
    }

}

extension BackupProto.FilePointer.LegacyAttachmentLocator : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var cdnId: UInt64 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: cdnId = try protoReader.decode(UInt64.self, encoding: .fixed)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.cdnId = cdnId
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.cdnId, encoding: .fixed)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.FilePointer.LegacyAttachmentLocator : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.cdnId = try container.decode(stringEncoded: UInt64.self, forKey: "cdnId")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || self.cdnId != 0 {
            try container.encode(stringEncoded: self.cdnId, forKey: "cdnId")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.FilePointer.UndownloadedBackupLocator : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.FilePointer.UndownloadedBackupLocator : Hashable {
}
#endif

extension BackupProto.FilePointer.UndownloadedBackupLocator : Sendable {
}

extension BackupProto.FilePointer.UndownloadedBackupLocator : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.FilePointer.UndownloadedBackupLocator"
    }

}

extension BackupProto.FilePointer.UndownloadedBackupLocator : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var senderAci: Foundation.Data = .init()
        var cdnKey: String = ""
        var cdnNumber: UInt32 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: senderAci = try protoReader.decode(Foundation.Data.self)
            case 2: cdnKey = try protoReader.decode(String.self)
            case 3: cdnNumber = try protoReader.decode(UInt32.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.senderAci = senderAci
        self.cdnKey = cdnKey
        self.cdnNumber = cdnNumber
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.senderAci)
        try protoWriter.encode(tag: 2, value: self.cdnKey)
        try protoWriter.encode(tag: 3, value: self.cdnNumber)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.FilePointer.UndownloadedBackupLocator : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.senderAci = try container.decode(stringEncoded: Foundation.Data.self, forKey: "senderAci")
        self.cdnKey = try container.decode(String.self, forKey: "cdnKey")
        self.cdnNumber = try container.decode(UInt32.self, forKey: "cdnNumber")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.senderAci.isEmpty {
            try container.encode(stringEncoded: self.senderAci, forKey: "senderAci")
        }
        if includeDefaults || !self.cdnKey.isEmpty {
            try container.encode(self.cdnKey, forKey: "cdnKey")
        }
        if includeDefaults || self.cdnNumber != 0 {
            try container.encode(self.cdnNumber, forKey: "cdnNumber")
        }
    }

}
#endif

extension BackupProto.FilePointer.Flags : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Quote : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Quote : Hashable {
}
#endif

extension BackupProto.Quote : Sendable {
}

extension BackupProto.Quote : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.Quote"
    }

}

extension BackupProto.Quote : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var targetSentTimestamp: UInt64? = nil
        var authorId: UInt64 = 0
        var text: String? = nil
        var attachments: [BackupProto.Quote.QuotedAttachment] = []
        var bodyRanges: [BackupProto.BodyRange] = []
        var type: BackupProto.Quote.Type_? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: targetSentTimestamp = try protoReader.decode(UInt64.self)
            case 2: authorId = try protoReader.decode(UInt64.self)
            case 3: text = try protoReader.decode(String.self)
            case 4: try protoReader.decode(into: &attachments)
            case 5: try protoReader.decode(into: &bodyRanges)
            case 6: type = try protoReader.decode(BackupProto.Quote.Type_.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._targetSentTimestamp.wrappedValue = targetSentTimestamp
        self.authorId = authorId
        self._text.wrappedValue = text
        self.attachments = attachments
        self.bodyRanges = bodyRanges
        self._type.wrappedValue = try BackupProto.Quote.Type_.defaultIfMissing(type)
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.targetSentTimestamp)
        try protoWriter.encode(tag: 2, value: self.authorId)
        try protoWriter.encode(tag: 3, value: self.text)
        try protoWriter.encode(tag: 4, value: self.attachments)
        try protoWriter.encode(tag: 5, value: self.bodyRanges)
        try protoWriter.encode(tag: 6, value: self.type)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.Quote : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._targetSentTimestamp.wrappedValue = try container.decodeIfPresent(stringEncoded: UInt64.self, forKey: "targetSentTimestamp")
        self.authorId = try container.decode(stringEncoded: UInt64.self, forKey: "authorId")
        self._text.wrappedValue = try container.decodeIfPresent(String.self, forKey: "text")
        self.attachments = try container.decodeProtoArray(BackupProto.Quote.QuotedAttachment.self, forKey: "attachments")
        self.bodyRanges = try container.decodeProtoArray(BackupProto.BodyRange.self, forKey: "bodyRanges")
        self._type.wrappedValue = try container.decodeIfPresent(BackupProto.Quote.Type_.self, forKey: "type")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(stringEncoded: self.targetSentTimestamp, forKey: "targetSentTimestamp")
        if includeDefaults || self.authorId != 0 {
            try container.encode(stringEncoded: self.authorId, forKey: "authorId")
        }
        try container.encodeIfPresent(self.text, forKey: "text")
        if includeDefaults || !self.attachments.isEmpty {
            try container.encodeProtoArray(self.attachments, forKey: "attachments")
        }
        if includeDefaults || !self.bodyRanges.isEmpty {
            try container.encodeProtoArray(self.bodyRanges, forKey: "bodyRanges")
        }
        try container.encodeIfPresent(self.type, forKey: "type")
    }

}
#endif

/**
 * Subtypes within BackupProto.Quote
 */
extension BackupProto.Quote {

    public enum Type_ : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN = 0
        case NORMAL = 1
        case GIFTBADGE = 2

        public static var defaultedValue: BackupProto.Quote.Type_ {
            BackupProto.Quote.Type_.UNKNOWN
        }
        public var description: String {
            switch self {
            case .UNKNOWN: return "UNKNOWN"
            case .NORMAL: return "NORMAL"
            case .GIFTBADGE: return "GIFTBADGE"
            }
        }

    }

    public struct QuotedAttachment {

        @ProtoDefaulted
        public var contentType: String?
        @ProtoDefaulted
        public var fileName: String?
        @ProtoDefaulted
        public var thumbnail: BackupProto.FilePointer?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

}

extension BackupProto.Quote.Type_ : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Quote.QuotedAttachment : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Quote.QuotedAttachment : Hashable {
}
#endif

extension BackupProto.Quote.QuotedAttachment : Sendable {
}

extension BackupProto.Quote.QuotedAttachment : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.Quote.QuotedAttachment {
        BackupProto.Quote.QuotedAttachment()
    }
}

extension BackupProto.Quote.QuotedAttachment : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.Quote.QuotedAttachment"
    }

}

extension BackupProto.Quote.QuotedAttachment : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var contentType: String? = nil
        var fileName: String? = nil
        var thumbnail: BackupProto.FilePointer? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: contentType = try protoReader.decode(String.self)
            case 2: fileName = try protoReader.decode(String.self)
            case 3: thumbnail = try protoReader.decode(BackupProto.FilePointer.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._contentType.wrappedValue = contentType
        self._fileName.wrappedValue = fileName
        self._thumbnail.wrappedValue = thumbnail
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.contentType)
        try protoWriter.encode(tag: 2, value: self.fileName)
        try protoWriter.encode(tag: 3, value: self.thumbnail)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.Quote.QuotedAttachment : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._contentType.wrappedValue = try container.decodeIfPresent(String.self, forKey: "contentType")
        self._fileName.wrappedValue = try container.decodeIfPresent(String.self, forKey: "fileName")
        self._thumbnail.wrappedValue = try container.decodeIfPresent(BackupProto.FilePointer.self, forKey: "thumbnail")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(self.contentType, forKey: "contentType")
        try container.encodeIfPresent(self.fileName, forKey: "fileName")
        try container.encodeIfPresent(self.thumbnail, forKey: "thumbnail")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.BodyRange : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.BodyRange : Hashable {
}
#endif

extension BackupProto.BodyRange : Sendable {
}

extension BackupProto.BodyRange : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.BodyRange {
        BackupProto.BodyRange()
    }
}

extension BackupProto.BodyRange : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.BodyRange"
    }

}

extension BackupProto.BodyRange : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var start: UInt32? = nil
        var length: UInt32? = nil
        var associatedValue: BackupProto.BodyRange.AssociatedValue? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: start = try protoReader.decode(UInt32.self)
            case 2: length = try protoReader.decode(UInt32.self)
            case 3: associatedValue = .mentionAci(try protoReader.decode(Foundation.Data.self))
            case 4: associatedValue = (try protoReader.decode(BackupProto.BodyRange.Style.self)).flatMap { .style($0) }
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._start.wrappedValue = start
        self._length.wrappedValue = length
        self.associatedValue = associatedValue
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.start)
        try protoWriter.encode(tag: 2, value: self.length)
        if let associatedValue = self.associatedValue {
            try associatedValue.encode(to: protoWriter)
        }
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.BodyRange : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._start.wrappedValue = try container.decodeIfPresent(UInt32.self, forKey: "start")
        self._length.wrappedValue = try container.decodeIfPresent(UInt32.self, forKey: "length")
        if let mentionAci = try container.decodeIfPresent(Foundation.Data.self, forKey: "mentionAci") {
            self.associatedValue = .mentionAci(mentionAci)
        } else if let style = try container.decodeIfPresent(BackupProto.BodyRange.Style.self, forKey: "style") {
            self.associatedValue = .style(style)
        } else {
            self.associatedValue = nil
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(self.start, forKey: "start")
        try container.encodeIfPresent(self.length, forKey: "length")
        switch self.associatedValue {
        case .mentionAci(let mentionAci): try container.encode(mentionAci, forKey: "mentionAci")
        case .style(let style): try container.encode(style, forKey: "style")
        case Optional.none: break
        }
    }

}
#endif

/**
 * Subtypes within BackupProto.BodyRange
 */
extension BackupProto.BodyRange {

    public enum AssociatedValue {

        case mentionAci(Foundation.Data)
        case style(BackupProto.BodyRange.Style)

        fileprivate func encode(to protoWriter: ProtoWriter) throws {
            switch self {
            case .mentionAci(let mentionAci): try protoWriter.encode(tag: 3, value: mentionAci)
            case .style(let style): try protoWriter.encode(tag: 4, value: style)
            }
        }

    }

    public enum Style : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case NONE = 0
        case BOLD = 1
        case ITALIC = 2
        case SPOILER = 3
        case STRIKETHROUGH = 4
        case MONOSPACE = 5

        public static var defaultedValue: BackupProto.BodyRange.Style {
            BackupProto.BodyRange.Style.NONE
        }
        public var description: String {
            switch self {
            case .NONE: return "NONE"
            case .BOLD: return "BOLD"
            case .ITALIC: return "ITALIC"
            case .SPOILER: return "SPOILER"
            case .STRIKETHROUGH: return "STRIKETHROUGH"
            case .MONOSPACE: return "MONOSPACE"
            }
        }

    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.BodyRange.AssociatedValue : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.BodyRange.AssociatedValue : Hashable {
}
#endif

extension BackupProto.BodyRange.AssociatedValue : Sendable {
}

extension BackupProto.BodyRange.Style : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.Reaction : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.Reaction : Hashable {
}
#endif

extension BackupProto.Reaction : Sendable {
}

extension BackupProto.Reaction : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.Reaction"
    }

}

extension BackupProto.Reaction : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var emoji: String = ""
        var authorId: UInt64 = 0
        var sentTimestamp: UInt64 = 0
        var receivedTimestamp: UInt64? = nil
        var sortOrder: UInt64 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: emoji = try protoReader.decode(String.self)
            case 2: authorId = try protoReader.decode(UInt64.self)
            case 3: sentTimestamp = try protoReader.decode(UInt64.self)
            case 4: receivedTimestamp = try protoReader.decode(UInt64.self)
            case 5: sortOrder = try protoReader.decode(UInt64.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.emoji = emoji
        self.authorId = authorId
        self.sentTimestamp = sentTimestamp
        self._receivedTimestamp.wrappedValue = receivedTimestamp
        self.sortOrder = sortOrder
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.emoji)
        try protoWriter.encode(tag: 2, value: self.authorId)
        try protoWriter.encode(tag: 3, value: self.sentTimestamp)
        try protoWriter.encode(tag: 4, value: self.receivedTimestamp)
        try protoWriter.encode(tag: 5, value: self.sortOrder)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.Reaction : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.emoji = try container.decode(String.self, forKey: "emoji")
        self.authorId = try container.decode(stringEncoded: UInt64.self, forKey: "authorId")
        self.sentTimestamp = try container.decode(stringEncoded: UInt64.self, forKey: "sentTimestamp")
        self._receivedTimestamp.wrappedValue = try container.decodeIfPresent(stringEncoded: UInt64.self, forKey: "receivedTimestamp")
        self.sortOrder = try container.decode(stringEncoded: UInt64.self, forKey: "sortOrder")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.emoji.isEmpty {
            try container.encode(self.emoji, forKey: "emoji")
        }
        if includeDefaults || self.authorId != 0 {
            try container.encode(stringEncoded: self.authorId, forKey: "authorId")
        }
        if includeDefaults || self.sentTimestamp != 0 {
            try container.encode(stringEncoded: self.sentTimestamp, forKey: "sentTimestamp")
        }
        try container.encodeIfPresent(stringEncoded: self.receivedTimestamp, forKey: "receivedTimestamp")
        if includeDefaults || self.sortOrder != 0 {
            try container.encode(stringEncoded: self.sortOrder, forKey: "sortOrder")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.ChatUpdateMessage : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.ChatUpdateMessage : Hashable {
}
#endif

extension BackupProto.ChatUpdateMessage : Sendable {
}

extension BackupProto.ChatUpdateMessage : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.ChatUpdateMessage {
        BackupProto.ChatUpdateMessage()
    }
}

extension BackupProto.ChatUpdateMessage : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.ChatUpdateMessage"
    }

}

extension BackupProto.ChatUpdateMessage : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var update: BackupProto.ChatUpdateMessage.Update? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: update = .simpleUpdate(try protoReader.decode(BackupProto.SimpleChatUpdate.self))
            case 2: update = .groupChange(try protoReader.decode(BackupProto.GroupChangeChatUpdate.self))
            case 3: update = .expirationTimerChange(try protoReader.decode(BackupProto.ExpirationTimerChatUpdate.self))
            case 4: update = .profileChange(try protoReader.decode(BackupProto.ProfileChangeChatUpdate.self))
            case 5: update = .threadMerge(try protoReader.decode(BackupProto.ThreadMergeChatUpdate.self))
            case 6: update = .sessionSwitchover(try protoReader.decode(BackupProto.SessionSwitchoverChatUpdate.self))
            case 7: update = .callingMessage(try protoReader.decode(BackupProto.CallChatUpdate.self))
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.update = update
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        if let update = self.update {
            try update.encode(to: protoWriter)
        }
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.ChatUpdateMessage : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        if let simpleUpdate = try container.decodeIfPresent(BackupProto.SimpleChatUpdate.self, forKey: "simpleUpdate") {
            self.update = .simpleUpdate(simpleUpdate)
        } else if let groupChange = try container.decodeIfPresent(BackupProto.GroupChangeChatUpdate.self, forKey: "groupChange") {
            self.update = .groupChange(groupChange)
        } else if let expirationTimerChange = try container.decodeIfPresent(BackupProto.ExpirationTimerChatUpdate.self, forKey: "expirationTimerChange") {
            self.update = .expirationTimerChange(expirationTimerChange)
        } else if let profileChange = try container.decodeIfPresent(BackupProto.ProfileChangeChatUpdate.self, forKey: "profileChange") {
            self.update = .profileChange(profileChange)
        } else if let threadMerge = try container.decodeIfPresent(BackupProto.ThreadMergeChatUpdate.self, forKey: "threadMerge") {
            self.update = .threadMerge(threadMerge)
        } else if let sessionSwitchover = try container.decodeIfPresent(BackupProto.SessionSwitchoverChatUpdate.self, forKey: "sessionSwitchover") {
            self.update = .sessionSwitchover(sessionSwitchover)
        } else if let callingMessage = try container.decodeIfPresent(BackupProto.CallChatUpdate.self, forKey: "callingMessage") {
            self.update = .callingMessage(callingMessage)
        } else {
            self.update = nil
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        switch self.update {
        case .simpleUpdate(let simpleUpdate): try container.encode(simpleUpdate, forKey: "simpleUpdate")
        case .groupChange(let groupChange): try container.encode(groupChange, forKey: "groupChange")
        case .expirationTimerChange(let expirationTimerChange): try container.encode(expirationTimerChange, forKey: "expirationTimerChange")
        case .profileChange(let profileChange): try container.encode(profileChange, forKey: "profileChange")
        case .threadMerge(let threadMerge): try container.encode(threadMerge, forKey: "threadMerge")
        case .sessionSwitchover(let sessionSwitchover): try container.encode(sessionSwitchover, forKey: "sessionSwitchover")
        case .callingMessage(let callingMessage): try container.encode(callingMessage, forKey: "callingMessage")
        case Optional.none: break
        }
    }

}
#endif

/**
 * Subtypes within BackupProto.ChatUpdateMessage
 */
extension BackupProto.ChatUpdateMessage {

    public enum Update {

        case simpleUpdate(BackupProto.SimpleChatUpdate)
        case groupChange(BackupProto.GroupChangeChatUpdate)
        case expirationTimerChange(BackupProto.ExpirationTimerChatUpdate)
        case profileChange(BackupProto.ProfileChangeChatUpdate)
        case threadMerge(BackupProto.ThreadMergeChatUpdate)
        case sessionSwitchover(BackupProto.SessionSwitchoverChatUpdate)
        case callingMessage(BackupProto.CallChatUpdate)

        fileprivate func encode(to protoWriter: ProtoWriter) throws {
            switch self {
            case .simpleUpdate(let simpleUpdate): try protoWriter.encode(tag: 1, value: simpleUpdate)
            case .groupChange(let groupChange): try protoWriter.encode(tag: 2, value: groupChange)
            case .expirationTimerChange(let expirationTimerChange): try protoWriter.encode(tag: 3, value: expirationTimerChange)
            case .profileChange(let profileChange): try protoWriter.encode(tag: 4, value: profileChange)
            case .threadMerge(let threadMerge): try protoWriter.encode(tag: 5, value: threadMerge)
            case .sessionSwitchover(let sessionSwitchover): try protoWriter.encode(tag: 6, value: sessionSwitchover)
            case .callingMessage(let callingMessage): try protoWriter.encode(tag: 7, value: callingMessage)
            }
        }

    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.ChatUpdateMessage.Update : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.ChatUpdateMessage.Update : Hashable {
}
#endif

extension BackupProto.ChatUpdateMessage.Update : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.CallChatUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.CallChatUpdate : Hashable {
}
#endif

extension BackupProto.CallChatUpdate : Sendable {
}

extension BackupProto.CallChatUpdate : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.CallChatUpdate {
        BackupProto.CallChatUpdate()
    }
}

extension BackupProto.CallChatUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.CallChatUpdate"
    }

}

extension BackupProto.CallChatUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var call: BackupProto.CallChatUpdate.Call? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: call = .callId(try protoReader.decode(UInt64.self))
            case 2: call = .callMessage(try protoReader.decode(BackupProto.IndividualCallChatUpdate.self))
            case 3: call = .groupCall(try protoReader.decode(BackupProto.GroupCallChatUpdate.self))
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.call = call
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        if let call = self.call {
            try call.encode(to: protoWriter)
        }
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.CallChatUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        if let callId = try container.decodeIfPresent(UInt64.self, forKey: "callId") {
            self.call = .callId(callId)
        } else if let callMessage = try container.decodeIfPresent(BackupProto.IndividualCallChatUpdate.self, forKey: "callMessage") {
            self.call = .callMessage(callMessage)
        } else if let groupCall = try container.decodeIfPresent(BackupProto.GroupCallChatUpdate.self, forKey: "groupCall") {
            self.call = .groupCall(groupCall)
        } else {
            self.call = nil
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        switch self.call {
        case .callId(let callId): try container.encode(callId, forKey: "callId")
        case .callMessage(let callMessage): try container.encode(callMessage, forKey: "callMessage")
        case .groupCall(let groupCall): try container.encode(groupCall, forKey: "groupCall")
        case Optional.none: break
        }
    }

}
#endif

/**
 * Subtypes within BackupProto.CallChatUpdate
 */
extension BackupProto.CallChatUpdate {

    public enum Call {

        /**
         * maps to id of call from call log
         */
        case callId(UInt64)
        case callMessage(BackupProto.IndividualCallChatUpdate)
        case groupCall(BackupProto.GroupCallChatUpdate)

        fileprivate func encode(to protoWriter: ProtoWriter) throws {
            switch self {
            case .callId(let callId): try protoWriter.encode(tag: 1, value: callId)
            case .callMessage(let callMessage): try protoWriter.encode(tag: 2, value: callMessage)
            case .groupCall(let groupCall): try protoWriter.encode(tag: 3, value: groupCall)
            }
        }

    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.CallChatUpdate.Call : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.CallChatUpdate.Call : Hashable {
}
#endif

extension BackupProto.CallChatUpdate.Call : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.IndividualCallChatUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.IndividualCallChatUpdate : Hashable {
}
#endif

extension BackupProto.IndividualCallChatUpdate : Sendable {
}

extension BackupProto.IndividualCallChatUpdate : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.IndividualCallChatUpdate {
        BackupProto.IndividualCallChatUpdate()
    }
}

extension BackupProto.IndividualCallChatUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.IndividualCallChatUpdate"
    }

}

extension BackupProto.IndividualCallChatUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.IndividualCallChatUpdate : Codable {

    public enum CodingKeys : CodingKey {
    }

}
#endif

/**
 * Subtypes within BackupProto.IndividualCallChatUpdate
 */
extension BackupProto.IndividualCallChatUpdate {

    public enum Type_ : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN = 0
        case INCOMING_AUDIO_CALL = 1
        case INCOMING_VIDEO_CALL = 2
        case OUTGOING_AUDIO_CALL = 3
        case OUTGOING_VIDEO_CALL = 4
        case MISSED_AUDIO_CALL = 5
        case MISSED_VIDEO_CALL = 6

        public static var defaultedValue: BackupProto.IndividualCallChatUpdate.Type_ {
            BackupProto.IndividualCallChatUpdate.Type_.UNKNOWN
        }
        public var description: String {
            switch self {
            case .UNKNOWN: return "UNKNOWN"
            case .INCOMING_AUDIO_CALL: return "INCOMING_AUDIO_CALL"
            case .INCOMING_VIDEO_CALL: return "INCOMING_VIDEO_CALL"
            case .OUTGOING_AUDIO_CALL: return "OUTGOING_AUDIO_CALL"
            case .OUTGOING_VIDEO_CALL: return "OUTGOING_VIDEO_CALL"
            case .MISSED_AUDIO_CALL: return "MISSED_AUDIO_CALL"
            case .MISSED_VIDEO_CALL: return "MISSED_VIDEO_CALL"
            }
        }

    }

}

extension BackupProto.IndividualCallChatUpdate.Type_ : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupCallChatUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupCallChatUpdate : Hashable {
}
#endif

extension BackupProto.GroupCallChatUpdate : Sendable {
}

extension BackupProto.GroupCallChatUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupCallChatUpdate"
    }

}

extension BackupProto.GroupCallChatUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var startedCallAci: Foundation.Data? = nil
        var startedCallTimestamp: UInt64 = 0
        var inCallAcis: [Foundation.Data] = []

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: startedCallAci = try protoReader.decode(Foundation.Data.self)
            case 2: startedCallTimestamp = try protoReader.decode(UInt64.self)
            case 3: try protoReader.decode(into: &inCallAcis)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._startedCallAci.wrappedValue = startedCallAci
        self.startedCallTimestamp = startedCallTimestamp
        self.inCallAcis = inCallAcis
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.startedCallAci)
        try protoWriter.encode(tag: 2, value: self.startedCallTimestamp)
        try protoWriter.encode(tag: 3, value: self.inCallAcis)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupCallChatUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._startedCallAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "startedCallAci")
        self.startedCallTimestamp = try container.decode(stringEncoded: UInt64.self, forKey: "startedCallTimestamp")
        self.inCallAcis = try container.decodeProtoArray(Foundation.Data.self, forKey: "inCallAcis")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(stringEncoded: self.startedCallAci, forKey: "startedCallAci")
        if includeDefaults || self.startedCallTimestamp != 0 {
            try container.encode(stringEncoded: self.startedCallTimestamp, forKey: "startedCallTimestamp")
        }
        if includeDefaults || !self.inCallAcis.isEmpty {
            try container.encodeProtoArray(self.inCallAcis, forKey: "inCallAcis")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.SimpleChatUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.SimpleChatUpdate : Hashable {
}
#endif

extension BackupProto.SimpleChatUpdate : Sendable {
}

extension BackupProto.SimpleChatUpdate : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.SimpleChatUpdate {
        BackupProto.SimpleChatUpdate()
    }
}

extension BackupProto.SimpleChatUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.SimpleChatUpdate"
    }

}

extension BackupProto.SimpleChatUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var type: BackupProto.SimpleChatUpdate.Type_? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: type = try protoReader.decode(BackupProto.SimpleChatUpdate.Type_.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._type.wrappedValue = try BackupProto.SimpleChatUpdate.Type_.defaultIfMissing(type)
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.type)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.SimpleChatUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._type.wrappedValue = try container.decodeIfPresent(BackupProto.SimpleChatUpdate.Type_.self, forKey: "type")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(self.type, forKey: "type")
    }

}
#endif

/**
 * Subtypes within BackupProto.SimpleChatUpdate
 */
extension BackupProto.SimpleChatUpdate {

    public enum Type_ : Int32, CaseIterable, ProtoEnum, ProtoDefaultedValue {

        case UNKNOWN = 0
        case JOINED_SIGNAL = 1
        case IDENTITY_UPDATE = 2
        case IDENTITY_VERIFIED = 3
        /**
         * marking as unverified
         */
        case IDENTITY_DEFAULT = 4
        case CHANGE_NUMBER = 5
        case BOOST_REQUEST = 6
        case END_SESSION = 7
        case CHAT_SESSION_REFRESH = 8
        case BAD_DECRYPT = 9
        case PAYMENTS_ACTIVATED = 10
        case PAYMENT_ACTIVATION_REQUEST = 11

        public static var defaultedValue: BackupProto.SimpleChatUpdate.Type_ {
            BackupProto.SimpleChatUpdate.Type_.UNKNOWN
        }
        public var description: String {
            switch self {
            case .UNKNOWN: return "UNKNOWN"
            case .JOINED_SIGNAL: return "JOINED_SIGNAL"
            case .IDENTITY_UPDATE: return "IDENTITY_UPDATE"
            case .IDENTITY_VERIFIED: return "IDENTITY_VERIFIED"
            case .IDENTITY_DEFAULT: return "IDENTITY_DEFAULT"
            case .CHANGE_NUMBER: return "CHANGE_NUMBER"
            case .BOOST_REQUEST: return "BOOST_REQUEST"
            case .END_SESSION: return "END_SESSION"
            case .CHAT_SESSION_REFRESH: return "CHAT_SESSION_REFRESH"
            case .BAD_DECRYPT: return "BAD_DECRYPT"
            case .PAYMENTS_ACTIVATED: return "PAYMENTS_ACTIVATED"
            case .PAYMENT_ACTIVATION_REQUEST: return "PAYMENT_ACTIVATION_REQUEST"
            }
        }

    }

}

extension BackupProto.SimpleChatUpdate.Type_ : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupDescriptionChatUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupDescriptionChatUpdate : Hashable {
}
#endif

extension BackupProto.GroupDescriptionChatUpdate : Sendable {
}

extension BackupProto.GroupDescriptionChatUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupDescriptionChatUpdate"
    }

}

extension BackupProto.GroupDescriptionChatUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var newDescription: String = ""

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: newDescription = try protoReader.decode(String.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.newDescription = newDescription
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.newDescription)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupDescriptionChatUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.newDescription = try container.decode(String.self, forKey: "newDescription")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.newDescription.isEmpty {
            try container.encode(self.newDescription, forKey: "newDescription")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.ExpirationTimerChatUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.ExpirationTimerChatUpdate : Hashable {
}
#endif

extension BackupProto.ExpirationTimerChatUpdate : Sendable {
}

extension BackupProto.ExpirationTimerChatUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.ExpirationTimerChatUpdate"
    }

}

extension BackupProto.ExpirationTimerChatUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var expiresInMs: UInt32 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: expiresInMs = try protoReader.decode(UInt32.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.expiresInMs = expiresInMs
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.expiresInMs)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.ExpirationTimerChatUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.expiresInMs = try container.decode(UInt32.self, forKey: "expiresInMs")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || self.expiresInMs != 0 {
            try container.encode(self.expiresInMs, forKey: "expiresInMs")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.ProfileChangeChatUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.ProfileChangeChatUpdate : Hashable {
}
#endif

extension BackupProto.ProfileChangeChatUpdate : Sendable {
}

extension BackupProto.ProfileChangeChatUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.ProfileChangeChatUpdate"
    }

}

extension BackupProto.ProfileChangeChatUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var previousName: String = ""
        var newName: String = ""

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: previousName = try protoReader.decode(String.self)
            case 2: newName = try protoReader.decode(String.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.previousName = previousName
        self.newName = newName
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.previousName)
        try protoWriter.encode(tag: 2, value: self.newName)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.ProfileChangeChatUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.previousName = try container.decode(String.self, forKey: "previousName")
        self.newName = try container.decode(String.self, forKey: "newName")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.previousName.isEmpty {
            try container.encode(self.previousName, forKey: "previousName")
        }
        if includeDefaults || !self.newName.isEmpty {
            try container.encode(self.newName, forKey: "newName")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.ThreadMergeChatUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.ThreadMergeChatUpdate : Hashable {
}
#endif

extension BackupProto.ThreadMergeChatUpdate : Sendable {
}

extension BackupProto.ThreadMergeChatUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.ThreadMergeChatUpdate"
    }

}

extension BackupProto.ThreadMergeChatUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var previousE164: UInt64 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: previousE164 = try protoReader.decode(UInt64.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.previousE164 = previousE164
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.previousE164)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.ThreadMergeChatUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.previousE164 = try container.decode(stringEncoded: UInt64.self, forKey: "previousE164")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || self.previousE164 != 0 {
            try container.encode(stringEncoded: self.previousE164, forKey: "previousE164")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.SessionSwitchoverChatUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.SessionSwitchoverChatUpdate : Hashable {
}
#endif

extension BackupProto.SessionSwitchoverChatUpdate : Sendable {
}

extension BackupProto.SessionSwitchoverChatUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.SessionSwitchoverChatUpdate"
    }

}

extension BackupProto.SessionSwitchoverChatUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var e164: UInt64 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: e164 = try protoReader.decode(UInt64.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.e164 = e164
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.e164)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.SessionSwitchoverChatUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.e164 = try container.decode(stringEncoded: UInt64.self, forKey: "e164")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || self.e164 != 0 {
            try container.encode(stringEncoded: self.e164, forKey: "e164")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupChangeChatUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupChangeChatUpdate : Hashable {
}
#endif

extension BackupProto.GroupChangeChatUpdate : Sendable {
}

extension BackupProto.GroupChangeChatUpdate : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.GroupChangeChatUpdate {
        BackupProto.GroupChangeChatUpdate()
    }
}

extension BackupProto.GroupChangeChatUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupChangeChatUpdate"
    }

}

extension BackupProto.GroupChangeChatUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var updates: [BackupProto.GroupChangeChatUpdate.Update] = []

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: try protoReader.decode(into: &updates)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.updates = updates
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.updates)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupChangeChatUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.updates = try container.decodeProtoArray(BackupProto.GroupChangeChatUpdate.Update.self, forKey: "updates")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.updates.isEmpty {
            try container.encodeProtoArray(self.updates, forKey: "updates")
        }
    }

}
#endif

/**
 * Subtypes within BackupProto.GroupChangeChatUpdate
 */
extension BackupProto.GroupChangeChatUpdate {

    public struct Update {

        /**
         * Note: group expiration timer changes are represented as ExpirationTimerChatUpdate.
         */
        public var update: BackupProto.GroupChangeChatUpdate.Update.Update?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupChangeChatUpdate.Update : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupChangeChatUpdate.Update : Hashable {
}
#endif

extension BackupProto.GroupChangeChatUpdate.Update : Sendable {
}

extension BackupProto.GroupChangeChatUpdate.Update : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.GroupChangeChatUpdate.Update {
        BackupProto.GroupChangeChatUpdate.Update()
    }
}

extension BackupProto.GroupChangeChatUpdate.Update : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupChangeChatUpdate.Update"
    }

}

extension BackupProto.GroupChangeChatUpdate.Update : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var update: BackupProto.GroupChangeChatUpdate.Update.Update? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: update = .genericGroupUpdate(try protoReader.decode(BackupProto.GenericGroupUpdate.self))
            case 2: update = .groupCreationUpdate(try protoReader.decode(BackupProto.GroupCreationUpdate.self))
            case 3: update = .groupNameUpdate(try protoReader.decode(BackupProto.GroupNameUpdate.self))
            case 4: update = .groupAvatarUpdate(try protoReader.decode(BackupProto.GroupAvatarUpdate.self))
            case 5: update = .groupDescriptionUpdate(try protoReader.decode(BackupProto.GroupDescriptionUpdate.self))
            case 6: update = .groupMembershipAccessLevelChangeUpdate(try protoReader.decode(BackupProto.GroupMembershipAccessLevelChangeUpdate.self))
            case 7: update = .groupAttributesAccessLevelChangeUpdate(try protoReader.decode(BackupProto.GroupAttributesAccessLevelChangeUpdate.self))
            case 8: update = .groupAnnouncementOnlyChangeUpdate(try protoReader.decode(BackupProto.GroupAnnouncementOnlyChangeUpdate.self))
            case 9: update = .groupAdminStatusUpdate(try protoReader.decode(BackupProto.GroupAdminStatusUpdate.self))
            case 10: update = .groupMemberLeftUpdate(try protoReader.decode(BackupProto.GroupMemberLeftUpdate.self))
            case 11: update = .groupMemberRemovedUpdate(try protoReader.decode(BackupProto.GroupMemberRemovedUpdate.self))
            case 12: update = .selfInvitedToGroupUpdate(try protoReader.decode(BackupProto.SelfInvitedToGroupUpdate.self))
            case 13: update = .selfInvitedOtherUserToGroupUpdate(try protoReader.decode(BackupProto.SelfInvitedOtherUserToGroupUpdate.self))
            case 14: update = .groupUnknownInviteeUpdate(try protoReader.decode(BackupProto.GroupUnknownInviteeUpdate.self))
            case 15: update = .groupInvitationAcceptedUpdate(try protoReader.decode(BackupProto.GroupInvitationAcceptedUpdate.self))
            case 16: update = .groupInvitationDeclinedUpdate(try protoReader.decode(BackupProto.GroupInvitationDeclinedUpdate.self))
            case 17: update = .groupMemberJoinedUpdate(try protoReader.decode(BackupProto.GroupMemberJoinedUpdate.self))
            case 18: update = .groupMemberAddedUpdate(try protoReader.decode(BackupProto.GroupMemberAddedUpdate.self))
            case 19: update = .groupSelfInvitationRevokedUpdate(try protoReader.decode(BackupProto.GroupSelfInvitationRevokedUpdate.self))
            case 20: update = .groupInvitationRevokedUpdate(try protoReader.decode(BackupProto.GroupInvitationRevokedUpdate.self))
            case 21: update = .groupJoinRequestUpdate(try protoReader.decode(BackupProto.GroupJoinRequestUpdate.self))
            case 22: update = .groupJoinRequestApprovalUpdate(try protoReader.decode(BackupProto.GroupJoinRequestApprovalUpdate.self))
            case 23: update = .groupJoinRequestCanceledUpdate(try protoReader.decode(BackupProto.GroupJoinRequestCanceledUpdate.self))
            case 24: update = .groupInviteLinkResetUpdate(try protoReader.decode(BackupProto.GroupInviteLinkResetUpdate.self))
            case 25: update = .groupInviteLinkEnabledUpdate(try protoReader.decode(BackupProto.GroupInviteLinkEnabledUpdate.self))
            case 26: update = .groupInviteLinkAdminApprovalUpdate(try protoReader.decode(BackupProto.GroupInviteLinkAdminApprovalUpdate.self))
            case 27: update = .groupInviteLinkDisabledUpdate(try protoReader.decode(BackupProto.GroupInviteLinkDisabledUpdate.self))
            case 28: update = .groupMemberJoinedByLinkUpdate(try protoReader.decode(BackupProto.GroupMemberJoinedByLinkUpdate.self))
            case 29: update = .groupV2MigrationUpdate(try protoReader.decode(BackupProto.GroupV2MigrationUpdate.self))
            case 30: update = .groupV2MigrationSelfInvitedUpdate(try protoReader.decode(BackupProto.GroupV2MigrationSelfInvitedUpdate.self))
            case 31: update = .groupV2MigrationInvitedMembersUpdate(try protoReader.decode(BackupProto.GroupV2MigrationInvitedMembersUpdate.self))
            case 32: update = .groupV2MigrationDroppedMembersUpdate(try protoReader.decode(BackupProto.GroupV2MigrationDroppedMembersUpdate.self))
            case 33: update = .groupSequenceOfRequestsAndCancelsUpdate(try protoReader.decode(BackupProto.GroupSequenceOfRequestsAndCancelsUpdate.self))
            case 34: update = .groupExpirationTimerUpdate(try protoReader.decode(BackupProto.GroupExpirationTimerUpdate.self))
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.update = update
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        if let update = self.update {
            try update.encode(to: protoWriter)
        }
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupChangeChatUpdate.Update : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        if let genericGroupUpdate = try container.decodeIfPresent(BackupProto.GenericGroupUpdate.self, forKey: "genericGroupUpdate") {
            self.update = .genericGroupUpdate(genericGroupUpdate)
        } else if let groupCreationUpdate = try container.decodeIfPresent(BackupProto.GroupCreationUpdate.self, forKey: "groupCreationUpdate") {
            self.update = .groupCreationUpdate(groupCreationUpdate)
        } else if let groupNameUpdate = try container.decodeIfPresent(BackupProto.GroupNameUpdate.self, forKey: "groupNameUpdate") {
            self.update = .groupNameUpdate(groupNameUpdate)
        } else if let groupAvatarUpdate = try container.decodeIfPresent(BackupProto.GroupAvatarUpdate.self, forKey: "groupAvatarUpdate") {
            self.update = .groupAvatarUpdate(groupAvatarUpdate)
        } else if let groupDescriptionUpdate = try container.decodeIfPresent(BackupProto.GroupDescriptionUpdate.self, forKey: "groupDescriptionUpdate") {
            self.update = .groupDescriptionUpdate(groupDescriptionUpdate)
        } else if let groupMembershipAccessLevelChangeUpdate = try container.decodeIfPresent(BackupProto.GroupMembershipAccessLevelChangeUpdate.self, forKey: "groupMembershipAccessLevelChangeUpdate") {
            self.update = .groupMembershipAccessLevelChangeUpdate(groupMembershipAccessLevelChangeUpdate)
        } else if let groupAttributesAccessLevelChangeUpdate = try container.decodeIfPresent(BackupProto.GroupAttributesAccessLevelChangeUpdate.self, forKey: "groupAttributesAccessLevelChangeUpdate") {
            self.update = .groupAttributesAccessLevelChangeUpdate(groupAttributesAccessLevelChangeUpdate)
        } else if let groupAnnouncementOnlyChangeUpdate = try container.decodeIfPresent(BackupProto.GroupAnnouncementOnlyChangeUpdate.self, forKey: "groupAnnouncementOnlyChangeUpdate") {
            self.update = .groupAnnouncementOnlyChangeUpdate(groupAnnouncementOnlyChangeUpdate)
        } else if let groupAdminStatusUpdate = try container.decodeIfPresent(BackupProto.GroupAdminStatusUpdate.self, forKey: "groupAdminStatusUpdate") {
            self.update = .groupAdminStatusUpdate(groupAdminStatusUpdate)
        } else if let groupMemberLeftUpdate = try container.decodeIfPresent(BackupProto.GroupMemberLeftUpdate.self, forKey: "groupMemberLeftUpdate") {
            self.update = .groupMemberLeftUpdate(groupMemberLeftUpdate)
        } else if let groupMemberRemovedUpdate = try container.decodeIfPresent(BackupProto.GroupMemberRemovedUpdate.self, forKey: "groupMemberRemovedUpdate") {
            self.update = .groupMemberRemovedUpdate(groupMemberRemovedUpdate)
        } else if let selfInvitedToGroupUpdate = try container.decodeIfPresent(BackupProto.SelfInvitedToGroupUpdate.self, forKey: "selfInvitedToGroupUpdate") {
            self.update = .selfInvitedToGroupUpdate(selfInvitedToGroupUpdate)
        } else if let selfInvitedOtherUserToGroupUpdate = try container.decodeIfPresent(BackupProto.SelfInvitedOtherUserToGroupUpdate.self, forKey: "selfInvitedOtherUserToGroupUpdate") {
            self.update = .selfInvitedOtherUserToGroupUpdate(selfInvitedOtherUserToGroupUpdate)
        } else if let groupUnknownInviteeUpdate = try container.decodeIfPresent(BackupProto.GroupUnknownInviteeUpdate.self, forKey: "groupUnknownInviteeUpdate") {
            self.update = .groupUnknownInviteeUpdate(groupUnknownInviteeUpdate)
        } else if let groupInvitationAcceptedUpdate = try container.decodeIfPresent(BackupProto.GroupInvitationAcceptedUpdate.self, forKey: "groupInvitationAcceptedUpdate") {
            self.update = .groupInvitationAcceptedUpdate(groupInvitationAcceptedUpdate)
        } else if let groupInvitationDeclinedUpdate = try container.decodeIfPresent(BackupProto.GroupInvitationDeclinedUpdate.self, forKey: "groupInvitationDeclinedUpdate") {
            self.update = .groupInvitationDeclinedUpdate(groupInvitationDeclinedUpdate)
        } else if let groupMemberJoinedUpdate = try container.decodeIfPresent(BackupProto.GroupMemberJoinedUpdate.self, forKey: "groupMemberJoinedUpdate") {
            self.update = .groupMemberJoinedUpdate(groupMemberJoinedUpdate)
        } else if let groupMemberAddedUpdate = try container.decodeIfPresent(BackupProto.GroupMemberAddedUpdate.self, forKey: "groupMemberAddedUpdate") {
            self.update = .groupMemberAddedUpdate(groupMemberAddedUpdate)
        } else if let groupSelfInvitationRevokedUpdate = try container.decodeIfPresent(BackupProto.GroupSelfInvitationRevokedUpdate.self, forKey: "groupSelfInvitationRevokedUpdate") {
            self.update = .groupSelfInvitationRevokedUpdate(groupSelfInvitationRevokedUpdate)
        } else if let groupInvitationRevokedUpdate = try container.decodeIfPresent(BackupProto.GroupInvitationRevokedUpdate.self, forKey: "groupInvitationRevokedUpdate") {
            self.update = .groupInvitationRevokedUpdate(groupInvitationRevokedUpdate)
        } else if let groupJoinRequestUpdate = try container.decodeIfPresent(BackupProto.GroupJoinRequestUpdate.self, forKey: "groupJoinRequestUpdate") {
            self.update = .groupJoinRequestUpdate(groupJoinRequestUpdate)
        } else if let groupJoinRequestApprovalUpdate = try container.decodeIfPresent(BackupProto.GroupJoinRequestApprovalUpdate.self, forKey: "groupJoinRequestApprovalUpdate") {
            self.update = .groupJoinRequestApprovalUpdate(groupJoinRequestApprovalUpdate)
        } else if let groupJoinRequestCanceledUpdate = try container.decodeIfPresent(BackupProto.GroupJoinRequestCanceledUpdate.self, forKey: "groupJoinRequestCanceledUpdate") {
            self.update = .groupJoinRequestCanceledUpdate(groupJoinRequestCanceledUpdate)
        } else if let groupInviteLinkResetUpdate = try container.decodeIfPresent(BackupProto.GroupInviteLinkResetUpdate.self, forKey: "groupInviteLinkResetUpdate") {
            self.update = .groupInviteLinkResetUpdate(groupInviteLinkResetUpdate)
        } else if let groupInviteLinkEnabledUpdate = try container.decodeIfPresent(BackupProto.GroupInviteLinkEnabledUpdate.self, forKey: "groupInviteLinkEnabledUpdate") {
            self.update = .groupInviteLinkEnabledUpdate(groupInviteLinkEnabledUpdate)
        } else if let groupInviteLinkAdminApprovalUpdate = try container.decodeIfPresent(BackupProto.GroupInviteLinkAdminApprovalUpdate.self, forKey: "groupInviteLinkAdminApprovalUpdate") {
            self.update = .groupInviteLinkAdminApprovalUpdate(groupInviteLinkAdminApprovalUpdate)
        } else if let groupInviteLinkDisabledUpdate = try container.decodeIfPresent(BackupProto.GroupInviteLinkDisabledUpdate.self, forKey: "groupInviteLinkDisabledUpdate") {
            self.update = .groupInviteLinkDisabledUpdate(groupInviteLinkDisabledUpdate)
        } else if let groupMemberJoinedByLinkUpdate = try container.decodeIfPresent(BackupProto.GroupMemberJoinedByLinkUpdate.self, forKey: "groupMemberJoinedByLinkUpdate") {
            self.update = .groupMemberJoinedByLinkUpdate(groupMemberJoinedByLinkUpdate)
        } else if let groupV2MigrationUpdate = try container.decodeIfPresent(BackupProto.GroupV2MigrationUpdate.self, forKey: "groupV2MigrationUpdate") {
            self.update = .groupV2MigrationUpdate(groupV2MigrationUpdate)
        } else if let groupV2MigrationSelfInvitedUpdate = try container.decodeIfPresent(BackupProto.GroupV2MigrationSelfInvitedUpdate.self, forKey: "groupV2MigrationSelfInvitedUpdate") {
            self.update = .groupV2MigrationSelfInvitedUpdate(groupV2MigrationSelfInvitedUpdate)
        } else if let groupV2MigrationInvitedMembersUpdate = try container.decodeIfPresent(BackupProto.GroupV2MigrationInvitedMembersUpdate.self, forKey: "groupV2MigrationInvitedMembersUpdate") {
            self.update = .groupV2MigrationInvitedMembersUpdate(groupV2MigrationInvitedMembersUpdate)
        } else if let groupV2MigrationDroppedMembersUpdate = try container.decodeIfPresent(BackupProto.GroupV2MigrationDroppedMembersUpdate.self, forKey: "groupV2MigrationDroppedMembersUpdate") {
            self.update = .groupV2MigrationDroppedMembersUpdate(groupV2MigrationDroppedMembersUpdate)
        } else if let groupSequenceOfRequestsAndCancelsUpdate = try container.decodeIfPresent(BackupProto.GroupSequenceOfRequestsAndCancelsUpdate.self, forKey: "groupSequenceOfRequestsAndCancelsUpdate") {
            self.update = .groupSequenceOfRequestsAndCancelsUpdate(groupSequenceOfRequestsAndCancelsUpdate)
        } else if let groupExpirationTimerUpdate = try container.decodeIfPresent(BackupProto.GroupExpirationTimerUpdate.self, forKey: "groupExpirationTimerUpdate") {
            self.update = .groupExpirationTimerUpdate(groupExpirationTimerUpdate)
        } else {
            self.update = nil
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        switch self.update {
        case .genericGroupUpdate(let genericGroupUpdate): try container.encode(genericGroupUpdate, forKey: "genericGroupUpdate")
        case .groupCreationUpdate(let groupCreationUpdate): try container.encode(groupCreationUpdate, forKey: "groupCreationUpdate")
        case .groupNameUpdate(let groupNameUpdate): try container.encode(groupNameUpdate, forKey: "groupNameUpdate")
        case .groupAvatarUpdate(let groupAvatarUpdate): try container.encode(groupAvatarUpdate, forKey: "groupAvatarUpdate")
        case .groupDescriptionUpdate(let groupDescriptionUpdate): try container.encode(groupDescriptionUpdate, forKey: "groupDescriptionUpdate")
        case .groupMembershipAccessLevelChangeUpdate(let groupMembershipAccessLevelChangeUpdate): try container.encode(groupMembershipAccessLevelChangeUpdate, forKey: "groupMembershipAccessLevelChangeUpdate")
        case .groupAttributesAccessLevelChangeUpdate(let groupAttributesAccessLevelChangeUpdate): try container.encode(groupAttributesAccessLevelChangeUpdate, forKey: "groupAttributesAccessLevelChangeUpdate")
        case .groupAnnouncementOnlyChangeUpdate(let groupAnnouncementOnlyChangeUpdate): try container.encode(groupAnnouncementOnlyChangeUpdate, forKey: "groupAnnouncementOnlyChangeUpdate")
        case .groupAdminStatusUpdate(let groupAdminStatusUpdate): try container.encode(groupAdminStatusUpdate, forKey: "groupAdminStatusUpdate")
        case .groupMemberLeftUpdate(let groupMemberLeftUpdate): try container.encode(groupMemberLeftUpdate, forKey: "groupMemberLeftUpdate")
        case .groupMemberRemovedUpdate(let groupMemberRemovedUpdate): try container.encode(groupMemberRemovedUpdate, forKey: "groupMemberRemovedUpdate")
        case .selfInvitedToGroupUpdate(let selfInvitedToGroupUpdate): try container.encode(selfInvitedToGroupUpdate, forKey: "selfInvitedToGroupUpdate")
        case .selfInvitedOtherUserToGroupUpdate(let selfInvitedOtherUserToGroupUpdate): try container.encode(selfInvitedOtherUserToGroupUpdate, forKey: "selfInvitedOtherUserToGroupUpdate")
        case .groupUnknownInviteeUpdate(let groupUnknownInviteeUpdate): try container.encode(groupUnknownInviteeUpdate, forKey: "groupUnknownInviteeUpdate")
        case .groupInvitationAcceptedUpdate(let groupInvitationAcceptedUpdate): try container.encode(groupInvitationAcceptedUpdate, forKey: "groupInvitationAcceptedUpdate")
        case .groupInvitationDeclinedUpdate(let groupInvitationDeclinedUpdate): try container.encode(groupInvitationDeclinedUpdate, forKey: "groupInvitationDeclinedUpdate")
        case .groupMemberJoinedUpdate(let groupMemberJoinedUpdate): try container.encode(groupMemberJoinedUpdate, forKey: "groupMemberJoinedUpdate")
        case .groupMemberAddedUpdate(let groupMemberAddedUpdate): try container.encode(groupMemberAddedUpdate, forKey: "groupMemberAddedUpdate")
        case .groupSelfInvitationRevokedUpdate(let groupSelfInvitationRevokedUpdate): try container.encode(groupSelfInvitationRevokedUpdate, forKey: "groupSelfInvitationRevokedUpdate")
        case .groupInvitationRevokedUpdate(let groupInvitationRevokedUpdate): try container.encode(groupInvitationRevokedUpdate, forKey: "groupInvitationRevokedUpdate")
        case .groupJoinRequestUpdate(let groupJoinRequestUpdate): try container.encode(groupJoinRequestUpdate, forKey: "groupJoinRequestUpdate")
        case .groupJoinRequestApprovalUpdate(let groupJoinRequestApprovalUpdate): try container.encode(groupJoinRequestApprovalUpdate, forKey: "groupJoinRequestApprovalUpdate")
        case .groupJoinRequestCanceledUpdate(let groupJoinRequestCanceledUpdate): try container.encode(groupJoinRequestCanceledUpdate, forKey: "groupJoinRequestCanceledUpdate")
        case .groupInviteLinkResetUpdate(let groupInviteLinkResetUpdate): try container.encode(groupInviteLinkResetUpdate, forKey: "groupInviteLinkResetUpdate")
        case .groupInviteLinkEnabledUpdate(let groupInviteLinkEnabledUpdate): try container.encode(groupInviteLinkEnabledUpdate, forKey: "groupInviteLinkEnabledUpdate")
        case .groupInviteLinkAdminApprovalUpdate(let groupInviteLinkAdminApprovalUpdate): try container.encode(groupInviteLinkAdminApprovalUpdate, forKey: "groupInviteLinkAdminApprovalUpdate")
        case .groupInviteLinkDisabledUpdate(let groupInviteLinkDisabledUpdate): try container.encode(groupInviteLinkDisabledUpdate, forKey: "groupInviteLinkDisabledUpdate")
        case .groupMemberJoinedByLinkUpdate(let groupMemberJoinedByLinkUpdate): try container.encode(groupMemberJoinedByLinkUpdate, forKey: "groupMemberJoinedByLinkUpdate")
        case .groupV2MigrationUpdate(let groupV2MigrationUpdate): try container.encode(groupV2MigrationUpdate, forKey: "groupV2MigrationUpdate")
        case .groupV2MigrationSelfInvitedUpdate(let groupV2MigrationSelfInvitedUpdate): try container.encode(groupV2MigrationSelfInvitedUpdate, forKey: "groupV2MigrationSelfInvitedUpdate")
        case .groupV2MigrationInvitedMembersUpdate(let groupV2MigrationInvitedMembersUpdate): try container.encode(groupV2MigrationInvitedMembersUpdate, forKey: "groupV2MigrationInvitedMembersUpdate")
        case .groupV2MigrationDroppedMembersUpdate(let groupV2MigrationDroppedMembersUpdate): try container.encode(groupV2MigrationDroppedMembersUpdate, forKey: "groupV2MigrationDroppedMembersUpdate")
        case .groupSequenceOfRequestsAndCancelsUpdate(let groupSequenceOfRequestsAndCancelsUpdate): try container.encode(groupSequenceOfRequestsAndCancelsUpdate, forKey: "groupSequenceOfRequestsAndCancelsUpdate")
        case .groupExpirationTimerUpdate(let groupExpirationTimerUpdate): try container.encode(groupExpirationTimerUpdate, forKey: "groupExpirationTimerUpdate")
        case Optional.none: break
        }
    }

}
#endif

/**
 * Subtypes within BackupProto.GroupChangeChatUpdate.Update
 */
extension BackupProto.GroupChangeChatUpdate.Update {

    public enum Update {

        case genericGroupUpdate(BackupProto.GenericGroupUpdate)
        case groupCreationUpdate(BackupProto.GroupCreationUpdate)
        case groupNameUpdate(BackupProto.GroupNameUpdate)
        case groupAvatarUpdate(BackupProto.GroupAvatarUpdate)
        case groupDescriptionUpdate(BackupProto.GroupDescriptionUpdate)
        case groupMembershipAccessLevelChangeUpdate(BackupProto.GroupMembershipAccessLevelChangeUpdate)
        case groupAttributesAccessLevelChangeUpdate(BackupProto.GroupAttributesAccessLevelChangeUpdate)
        case groupAnnouncementOnlyChangeUpdate(BackupProto.GroupAnnouncementOnlyChangeUpdate)
        case groupAdminStatusUpdate(BackupProto.GroupAdminStatusUpdate)
        case groupMemberLeftUpdate(BackupProto.GroupMemberLeftUpdate)
        case groupMemberRemovedUpdate(BackupProto.GroupMemberRemovedUpdate)
        case selfInvitedToGroupUpdate(BackupProto.SelfInvitedToGroupUpdate)
        case selfInvitedOtherUserToGroupUpdate(BackupProto.SelfInvitedOtherUserToGroupUpdate)
        case groupUnknownInviteeUpdate(BackupProto.GroupUnknownInviteeUpdate)
        case groupInvitationAcceptedUpdate(BackupProto.GroupInvitationAcceptedUpdate)
        case groupInvitationDeclinedUpdate(BackupProto.GroupInvitationDeclinedUpdate)
        case groupMemberJoinedUpdate(BackupProto.GroupMemberJoinedUpdate)
        case groupMemberAddedUpdate(BackupProto.GroupMemberAddedUpdate)
        case groupSelfInvitationRevokedUpdate(BackupProto.GroupSelfInvitationRevokedUpdate)
        case groupInvitationRevokedUpdate(BackupProto.GroupInvitationRevokedUpdate)
        case groupJoinRequestUpdate(BackupProto.GroupJoinRequestUpdate)
        case groupJoinRequestApprovalUpdate(BackupProto.GroupJoinRequestApprovalUpdate)
        case groupJoinRequestCanceledUpdate(BackupProto.GroupJoinRequestCanceledUpdate)
        case groupInviteLinkResetUpdate(BackupProto.GroupInviteLinkResetUpdate)
        case groupInviteLinkEnabledUpdate(BackupProto.GroupInviteLinkEnabledUpdate)
        case groupInviteLinkAdminApprovalUpdate(BackupProto.GroupInviteLinkAdminApprovalUpdate)
        case groupInviteLinkDisabledUpdate(BackupProto.GroupInviteLinkDisabledUpdate)
        case groupMemberJoinedByLinkUpdate(BackupProto.GroupMemberJoinedByLinkUpdate)
        case groupV2MigrationUpdate(BackupProto.GroupV2MigrationUpdate)
        case groupV2MigrationSelfInvitedUpdate(BackupProto.GroupV2MigrationSelfInvitedUpdate)
        case groupV2MigrationInvitedMembersUpdate(BackupProto.GroupV2MigrationInvitedMembersUpdate)
        case groupV2MigrationDroppedMembersUpdate(BackupProto.GroupV2MigrationDroppedMembersUpdate)
        case groupSequenceOfRequestsAndCancelsUpdate(BackupProto.GroupSequenceOfRequestsAndCancelsUpdate)
        case groupExpirationTimerUpdate(BackupProto.GroupExpirationTimerUpdate)

        fileprivate func encode(to protoWriter: ProtoWriter) throws {
            switch self {
            case .genericGroupUpdate(let genericGroupUpdate): try protoWriter.encode(tag: 1, value: genericGroupUpdate)
            case .groupCreationUpdate(let groupCreationUpdate): try protoWriter.encode(tag: 2, value: groupCreationUpdate)
            case .groupNameUpdate(let groupNameUpdate): try protoWriter.encode(tag: 3, value: groupNameUpdate)
            case .groupAvatarUpdate(let groupAvatarUpdate): try protoWriter.encode(tag: 4, value: groupAvatarUpdate)
            case .groupDescriptionUpdate(let groupDescriptionUpdate): try protoWriter.encode(tag: 5, value: groupDescriptionUpdate)
            case .groupMembershipAccessLevelChangeUpdate(let groupMembershipAccessLevelChangeUpdate): try protoWriter.encode(tag: 6, value: groupMembershipAccessLevelChangeUpdate)
            case .groupAttributesAccessLevelChangeUpdate(let groupAttributesAccessLevelChangeUpdate): try protoWriter.encode(tag: 7, value: groupAttributesAccessLevelChangeUpdate)
            case .groupAnnouncementOnlyChangeUpdate(let groupAnnouncementOnlyChangeUpdate): try protoWriter.encode(tag: 8, value: groupAnnouncementOnlyChangeUpdate)
            case .groupAdminStatusUpdate(let groupAdminStatusUpdate): try protoWriter.encode(tag: 9, value: groupAdminStatusUpdate)
            case .groupMemberLeftUpdate(let groupMemberLeftUpdate): try protoWriter.encode(tag: 10, value: groupMemberLeftUpdate)
            case .groupMemberRemovedUpdate(let groupMemberRemovedUpdate): try protoWriter.encode(tag: 11, value: groupMemberRemovedUpdate)
            case .selfInvitedToGroupUpdate(let selfInvitedToGroupUpdate): try protoWriter.encode(tag: 12, value: selfInvitedToGroupUpdate)
            case .selfInvitedOtherUserToGroupUpdate(let selfInvitedOtherUserToGroupUpdate): try protoWriter.encode(tag: 13, value: selfInvitedOtherUserToGroupUpdate)
            case .groupUnknownInviteeUpdate(let groupUnknownInviteeUpdate): try protoWriter.encode(tag: 14, value: groupUnknownInviteeUpdate)
            case .groupInvitationAcceptedUpdate(let groupInvitationAcceptedUpdate): try protoWriter.encode(tag: 15, value: groupInvitationAcceptedUpdate)
            case .groupInvitationDeclinedUpdate(let groupInvitationDeclinedUpdate): try protoWriter.encode(tag: 16, value: groupInvitationDeclinedUpdate)
            case .groupMemberJoinedUpdate(let groupMemberJoinedUpdate): try protoWriter.encode(tag: 17, value: groupMemberJoinedUpdate)
            case .groupMemberAddedUpdate(let groupMemberAddedUpdate): try protoWriter.encode(tag: 18, value: groupMemberAddedUpdate)
            case .groupSelfInvitationRevokedUpdate(let groupSelfInvitationRevokedUpdate): try protoWriter.encode(tag: 19, value: groupSelfInvitationRevokedUpdate)
            case .groupInvitationRevokedUpdate(let groupInvitationRevokedUpdate): try protoWriter.encode(tag: 20, value: groupInvitationRevokedUpdate)
            case .groupJoinRequestUpdate(let groupJoinRequestUpdate): try protoWriter.encode(tag: 21, value: groupJoinRequestUpdate)
            case .groupJoinRequestApprovalUpdate(let groupJoinRequestApprovalUpdate): try protoWriter.encode(tag: 22, value: groupJoinRequestApprovalUpdate)
            case .groupJoinRequestCanceledUpdate(let groupJoinRequestCanceledUpdate): try protoWriter.encode(tag: 23, value: groupJoinRequestCanceledUpdate)
            case .groupInviteLinkResetUpdate(let groupInviteLinkResetUpdate): try protoWriter.encode(tag: 24, value: groupInviteLinkResetUpdate)
            case .groupInviteLinkEnabledUpdate(let groupInviteLinkEnabledUpdate): try protoWriter.encode(tag: 25, value: groupInviteLinkEnabledUpdate)
            case .groupInviteLinkAdminApprovalUpdate(let groupInviteLinkAdminApprovalUpdate): try protoWriter.encode(tag: 26, value: groupInviteLinkAdminApprovalUpdate)
            case .groupInviteLinkDisabledUpdate(let groupInviteLinkDisabledUpdate): try protoWriter.encode(tag: 27, value: groupInviteLinkDisabledUpdate)
            case .groupMemberJoinedByLinkUpdate(let groupMemberJoinedByLinkUpdate): try protoWriter.encode(tag: 28, value: groupMemberJoinedByLinkUpdate)
            case .groupV2MigrationUpdate(let groupV2MigrationUpdate): try protoWriter.encode(tag: 29, value: groupV2MigrationUpdate)
            case .groupV2MigrationSelfInvitedUpdate(let groupV2MigrationSelfInvitedUpdate): try protoWriter.encode(tag: 30, value: groupV2MigrationSelfInvitedUpdate)
            case .groupV2MigrationInvitedMembersUpdate(let groupV2MigrationInvitedMembersUpdate): try protoWriter.encode(tag: 31, value: groupV2MigrationInvitedMembersUpdate)
            case .groupV2MigrationDroppedMembersUpdate(let groupV2MigrationDroppedMembersUpdate): try protoWriter.encode(tag: 32, value: groupV2MigrationDroppedMembersUpdate)
            case .groupSequenceOfRequestsAndCancelsUpdate(let groupSequenceOfRequestsAndCancelsUpdate): try protoWriter.encode(tag: 33, value: groupSequenceOfRequestsAndCancelsUpdate)
            case .groupExpirationTimerUpdate(let groupExpirationTimerUpdate): try protoWriter.encode(tag: 34, value: groupExpirationTimerUpdate)
            }
        }

    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupChangeChatUpdate.Update.Update : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupChangeChatUpdate.Update.Update : Hashable {
}
#endif

extension BackupProto.GroupChangeChatUpdate.Update.Update : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GenericGroupUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GenericGroupUpdate : Hashable {
}
#endif

extension BackupProto.GenericGroupUpdate : Sendable {
}

extension BackupProto.GenericGroupUpdate : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.GenericGroupUpdate {
        BackupProto.GenericGroupUpdate()
    }
}

extension BackupProto.GenericGroupUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GenericGroupUpdate"
    }

}

extension BackupProto.GenericGroupUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var updaterAci: Foundation.Data? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: updaterAci = try protoReader.decode(Foundation.Data.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._updaterAci.wrappedValue = updaterAci
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.updaterAci)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GenericGroupUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._updaterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "updaterAci")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(stringEncoded: self.updaterAci, forKey: "updaterAci")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupCreationUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupCreationUpdate : Hashable {
}
#endif

extension BackupProto.GroupCreationUpdate : Sendable {
}

extension BackupProto.GroupCreationUpdate : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.GroupCreationUpdate {
        BackupProto.GroupCreationUpdate()
    }
}

extension BackupProto.GroupCreationUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupCreationUpdate"
    }

}

extension BackupProto.GroupCreationUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var updaterAci: Foundation.Data? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: updaterAci = try protoReader.decode(Foundation.Data.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._updaterAci.wrappedValue = updaterAci
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.updaterAci)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupCreationUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._updaterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "updaterAci")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(stringEncoded: self.updaterAci, forKey: "updaterAci")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupNameUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupNameUpdate : Hashable {
}
#endif

extension BackupProto.GroupNameUpdate : Sendable {
}

extension BackupProto.GroupNameUpdate : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.GroupNameUpdate {
        BackupProto.GroupNameUpdate()
    }
}

extension BackupProto.GroupNameUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupNameUpdate"
    }

}

extension BackupProto.GroupNameUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var updaterAci: Foundation.Data? = nil
        var newGroupName: String? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: updaterAci = try protoReader.decode(Foundation.Data.self)
            case 2: newGroupName = try protoReader.decode(String.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._updaterAci.wrappedValue = updaterAci
        self._newGroupName.wrappedValue = newGroupName
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.updaterAci)
        try protoWriter.encode(tag: 2, value: self.newGroupName)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupNameUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._updaterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "updaterAci")
        self._newGroupName.wrappedValue = try container.decodeIfPresent(String.self, forKey: "newGroupName")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(stringEncoded: self.updaterAci, forKey: "updaterAci")
        try container.encodeIfPresent(self.newGroupName, forKey: "newGroupName")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupAvatarUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupAvatarUpdate : Hashable {
}
#endif

extension BackupProto.GroupAvatarUpdate : Sendable {
}

extension BackupProto.GroupAvatarUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupAvatarUpdate"
    }

}

extension BackupProto.GroupAvatarUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var updaterAci: Foundation.Data? = nil
        var wasRemoved: Bool = false

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: updaterAci = try protoReader.decode(Foundation.Data.self)
            case 2: wasRemoved = try protoReader.decode(Bool.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._updaterAci.wrappedValue = updaterAci
        self.wasRemoved = wasRemoved
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.updaterAci)
        try protoWriter.encode(tag: 2, value: self.wasRemoved)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupAvatarUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._updaterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "updaterAci")
        self.wasRemoved = try container.decode(Bool.self, forKey: "wasRemoved")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(stringEncoded: self.updaterAci, forKey: "updaterAci")
        if includeDefaults || self.wasRemoved != false {
            try container.encode(self.wasRemoved, forKey: "wasRemoved")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupDescriptionUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupDescriptionUpdate : Hashable {
}
#endif

extension BackupProto.GroupDescriptionUpdate : Sendable {
}

extension BackupProto.GroupDescriptionUpdate : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.GroupDescriptionUpdate {
        BackupProto.GroupDescriptionUpdate()
    }
}

extension BackupProto.GroupDescriptionUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupDescriptionUpdate"
    }

}

extension BackupProto.GroupDescriptionUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var updaterAci: Foundation.Data? = nil
        var newDescription: String? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: updaterAci = try protoReader.decode(Foundation.Data.self)
            case 2: newDescription = try protoReader.decode(String.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._updaterAci.wrappedValue = updaterAci
        self._newDescription.wrappedValue = newDescription
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.updaterAci)
        try protoWriter.encode(tag: 2, value: self.newDescription)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupDescriptionUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._updaterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "updaterAci")
        self._newDescription.wrappedValue = try container.decodeIfPresent(String.self, forKey: "newDescription")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(stringEncoded: self.updaterAci, forKey: "updaterAci")
        try container.encodeIfPresent(self.newDescription, forKey: "newDescription")
    }

}
#endif

extension BackupProto.GroupV2AccessLevel : Sendable {
}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupMembershipAccessLevelChangeUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupMembershipAccessLevelChangeUpdate : Hashable {
}
#endif

extension BackupProto.GroupMembershipAccessLevelChangeUpdate : Sendable {
}

extension BackupProto.GroupMembershipAccessLevelChangeUpdate : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.GroupMembershipAccessLevelChangeUpdate {
        BackupProto.GroupMembershipAccessLevelChangeUpdate()
    }
}

extension BackupProto.GroupMembershipAccessLevelChangeUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupMembershipAccessLevelChangeUpdate"
    }

}

extension BackupProto.GroupMembershipAccessLevelChangeUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var updaterAci: Foundation.Data? = nil
        var accessLevel: BackupProto.GroupV2AccessLevel? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: updaterAci = try protoReader.decode(Foundation.Data.self)
            case 2: accessLevel = try protoReader.decode(BackupProto.GroupV2AccessLevel.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._updaterAci.wrappedValue = updaterAci
        self._accessLevel.wrappedValue = try BackupProto.GroupV2AccessLevel.defaultIfMissing(accessLevel)
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.updaterAci)
        try protoWriter.encode(tag: 2, value: self.accessLevel)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupMembershipAccessLevelChangeUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._updaterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "updaterAci")
        self._accessLevel.wrappedValue = try container.decodeIfPresent(BackupProto.GroupV2AccessLevel.self, forKey: "accessLevel")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(stringEncoded: self.updaterAci, forKey: "updaterAci")
        try container.encodeIfPresent(self.accessLevel, forKey: "accessLevel")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupAttributesAccessLevelChangeUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupAttributesAccessLevelChangeUpdate : Hashable {
}
#endif

extension BackupProto.GroupAttributesAccessLevelChangeUpdate : Sendable {
}

extension BackupProto.GroupAttributesAccessLevelChangeUpdate : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.GroupAttributesAccessLevelChangeUpdate {
        BackupProto.GroupAttributesAccessLevelChangeUpdate()
    }
}

extension BackupProto.GroupAttributesAccessLevelChangeUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupAttributesAccessLevelChangeUpdate"
    }

}

extension BackupProto.GroupAttributesAccessLevelChangeUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var updaterAci: Foundation.Data? = nil
        var accessLevel: BackupProto.GroupV2AccessLevel? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: updaterAci = try protoReader.decode(Foundation.Data.self)
            case 2: accessLevel = try protoReader.decode(BackupProto.GroupV2AccessLevel.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._updaterAci.wrappedValue = updaterAci
        self._accessLevel.wrappedValue = try BackupProto.GroupV2AccessLevel.defaultIfMissing(accessLevel)
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.updaterAci)
        try protoWriter.encode(tag: 2, value: self.accessLevel)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupAttributesAccessLevelChangeUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._updaterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "updaterAci")
        self._accessLevel.wrappedValue = try container.decodeIfPresent(BackupProto.GroupV2AccessLevel.self, forKey: "accessLevel")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(stringEncoded: self.updaterAci, forKey: "updaterAci")
        try container.encodeIfPresent(self.accessLevel, forKey: "accessLevel")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupAnnouncementOnlyChangeUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupAnnouncementOnlyChangeUpdate : Hashable {
}
#endif

extension BackupProto.GroupAnnouncementOnlyChangeUpdate : Sendable {
}

extension BackupProto.GroupAnnouncementOnlyChangeUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupAnnouncementOnlyChangeUpdate"
    }

}

extension BackupProto.GroupAnnouncementOnlyChangeUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var updaterAci: Foundation.Data? = nil
        var isAnnouncementOnly: Bool = false

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: updaterAci = try protoReader.decode(Foundation.Data.self)
            case 2: isAnnouncementOnly = try protoReader.decode(Bool.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._updaterAci.wrappedValue = updaterAci
        self.isAnnouncementOnly = isAnnouncementOnly
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.updaterAci)
        try protoWriter.encode(tag: 2, value: self.isAnnouncementOnly)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupAnnouncementOnlyChangeUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._updaterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "updaterAci")
        self.isAnnouncementOnly = try container.decode(Bool.self, forKey: "isAnnouncementOnly")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(stringEncoded: self.updaterAci, forKey: "updaterAci")
        if includeDefaults || self.isAnnouncementOnly != false {
            try container.encode(self.isAnnouncementOnly, forKey: "isAnnouncementOnly")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupAdminStatusUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupAdminStatusUpdate : Hashable {
}
#endif

extension BackupProto.GroupAdminStatusUpdate : Sendable {
}

extension BackupProto.GroupAdminStatusUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupAdminStatusUpdate"
    }

}

extension BackupProto.GroupAdminStatusUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var updaterAci: Foundation.Data? = nil
        var memberAci: Foundation.Data = .init()
        var wasAdminStatusGranted: Bool = false

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: updaterAci = try protoReader.decode(Foundation.Data.self)
            case 2: memberAci = try protoReader.decode(Foundation.Data.self)
            case 3: wasAdminStatusGranted = try protoReader.decode(Bool.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._updaterAci.wrappedValue = updaterAci
        self.memberAci = memberAci
        self.wasAdminStatusGranted = wasAdminStatusGranted
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.updaterAci)
        try protoWriter.encode(tag: 2, value: self.memberAci)
        try protoWriter.encode(tag: 3, value: self.wasAdminStatusGranted)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupAdminStatusUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._updaterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "updaterAci")
        self.memberAci = try container.decode(stringEncoded: Foundation.Data.self, forKey: "memberAci")
        self.wasAdminStatusGranted = try container.decode(Bool.self, forKey: "wasAdminStatusGranted")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(stringEncoded: self.updaterAci, forKey: "updaterAci")
        if includeDefaults || !self.memberAci.isEmpty {
            try container.encode(stringEncoded: self.memberAci, forKey: "memberAci")
        }
        if includeDefaults || self.wasAdminStatusGranted != false {
            try container.encode(self.wasAdminStatusGranted, forKey: "wasAdminStatusGranted")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupMemberLeftUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupMemberLeftUpdate : Hashable {
}
#endif

extension BackupProto.GroupMemberLeftUpdate : Sendable {
}

extension BackupProto.GroupMemberLeftUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupMemberLeftUpdate"
    }

}

extension BackupProto.GroupMemberLeftUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var aci: Foundation.Data = .init()

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: aci = try protoReader.decode(Foundation.Data.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.aci = aci
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.aci)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupMemberLeftUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.aci = try container.decode(stringEncoded: Foundation.Data.self, forKey: "aci")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.aci.isEmpty {
            try container.encode(stringEncoded: self.aci, forKey: "aci")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupMemberRemovedUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupMemberRemovedUpdate : Hashable {
}
#endif

extension BackupProto.GroupMemberRemovedUpdate : Sendable {
}

extension BackupProto.GroupMemberRemovedUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupMemberRemovedUpdate"
    }

}

extension BackupProto.GroupMemberRemovedUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var removerAci: Foundation.Data? = nil
        var removedAci: Foundation.Data = .init()

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: removerAci = try protoReader.decode(Foundation.Data.self)
            case 2: removedAci = try protoReader.decode(Foundation.Data.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._removerAci.wrappedValue = removerAci
        self.removedAci = removedAci
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.removerAci)
        try protoWriter.encode(tag: 2, value: self.removedAci)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupMemberRemovedUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._removerAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "removerAci")
        self.removedAci = try container.decode(stringEncoded: Foundation.Data.self, forKey: "removedAci")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(stringEncoded: self.removerAci, forKey: "removerAci")
        if includeDefaults || !self.removedAci.isEmpty {
            try container.encode(stringEncoded: self.removedAci, forKey: "removedAci")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.SelfInvitedToGroupUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.SelfInvitedToGroupUpdate : Hashable {
}
#endif

extension BackupProto.SelfInvitedToGroupUpdate : Sendable {
}

extension BackupProto.SelfInvitedToGroupUpdate : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.SelfInvitedToGroupUpdate {
        BackupProto.SelfInvitedToGroupUpdate()
    }
}

extension BackupProto.SelfInvitedToGroupUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.SelfInvitedToGroupUpdate"
    }

}

extension BackupProto.SelfInvitedToGroupUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var inviterAci: Foundation.Data? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: inviterAci = try protoReader.decode(Foundation.Data.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._inviterAci.wrappedValue = inviterAci
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.inviterAci)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.SelfInvitedToGroupUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._inviterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "inviterAci")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(stringEncoded: self.inviterAci, forKey: "inviterAci")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.SelfInvitedOtherUserToGroupUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.SelfInvitedOtherUserToGroupUpdate : Hashable {
}
#endif

extension BackupProto.SelfInvitedOtherUserToGroupUpdate : Sendable {
}

extension BackupProto.SelfInvitedOtherUserToGroupUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.SelfInvitedOtherUserToGroupUpdate"
    }

}

extension BackupProto.SelfInvitedOtherUserToGroupUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var inviteeServiceId: Foundation.Data = .init()

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: inviteeServiceId = try protoReader.decode(Foundation.Data.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.inviteeServiceId = inviteeServiceId
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.inviteeServiceId)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.SelfInvitedOtherUserToGroupUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.inviteeServiceId = try container.decode(stringEncoded: Foundation.Data.self, forKey: "inviteeServiceId")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.inviteeServiceId.isEmpty {
            try container.encode(stringEncoded: self.inviteeServiceId, forKey: "inviteeServiceId")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupUnknownInviteeUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupUnknownInviteeUpdate : Hashable {
}
#endif

extension BackupProto.GroupUnknownInviteeUpdate : Sendable {
}

extension BackupProto.GroupUnknownInviteeUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupUnknownInviteeUpdate"
    }

}

extension BackupProto.GroupUnknownInviteeUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var inviterAci: Foundation.Data? = nil
        var inviteeCount: UInt32 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: inviterAci = try protoReader.decode(Foundation.Data.self)
            case 2: inviteeCount = try protoReader.decode(UInt32.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._inviterAci.wrappedValue = inviterAci
        self.inviteeCount = inviteeCount
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.inviterAci)
        try protoWriter.encode(tag: 2, value: self.inviteeCount)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupUnknownInviteeUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._inviterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "inviterAci")
        self.inviteeCount = try container.decode(UInt32.self, forKey: "inviteeCount")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(stringEncoded: self.inviterAci, forKey: "inviterAci")
        if includeDefaults || self.inviteeCount != 0 {
            try container.encode(self.inviteeCount, forKey: "inviteeCount")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupInvitationAcceptedUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupInvitationAcceptedUpdate : Hashable {
}
#endif

extension BackupProto.GroupInvitationAcceptedUpdate : Sendable {
}

extension BackupProto.GroupInvitationAcceptedUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupInvitationAcceptedUpdate"
    }

}

extension BackupProto.GroupInvitationAcceptedUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var inviterAci: Foundation.Data? = nil
        var newMemberAci: Foundation.Data = .init()

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: inviterAci = try protoReader.decode(Foundation.Data.self)
            case 2: newMemberAci = try protoReader.decode(Foundation.Data.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._inviterAci.wrappedValue = inviterAci
        self.newMemberAci = newMemberAci
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.inviterAci)
        try protoWriter.encode(tag: 2, value: self.newMemberAci)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupInvitationAcceptedUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._inviterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "inviterAci")
        self.newMemberAci = try container.decode(stringEncoded: Foundation.Data.self, forKey: "newMemberAci")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(stringEncoded: self.inviterAci, forKey: "inviterAci")
        if includeDefaults || !self.newMemberAci.isEmpty {
            try container.encode(stringEncoded: self.newMemberAci, forKey: "newMemberAci")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupInvitationDeclinedUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupInvitationDeclinedUpdate : Hashable {
}
#endif

extension BackupProto.GroupInvitationDeclinedUpdate : Sendable {
}

extension BackupProto.GroupInvitationDeclinedUpdate : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.GroupInvitationDeclinedUpdate {
        BackupProto.GroupInvitationDeclinedUpdate()
    }
}

extension BackupProto.GroupInvitationDeclinedUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupInvitationDeclinedUpdate"
    }

}

extension BackupProto.GroupInvitationDeclinedUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var inviterAci: Foundation.Data? = nil
        var inviteeAci: Foundation.Data? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: inviterAci = try protoReader.decode(Foundation.Data.self)
            case 2: inviteeAci = try protoReader.decode(Foundation.Data.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._inviterAci.wrappedValue = inviterAci
        self._inviteeAci.wrappedValue = inviteeAci
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.inviterAci)
        try protoWriter.encode(tag: 2, value: self.inviteeAci)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupInvitationDeclinedUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._inviterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "inviterAci")
        self._inviteeAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "inviteeAci")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(stringEncoded: self.inviterAci, forKey: "inviterAci")
        try container.encodeIfPresent(stringEncoded: self.inviteeAci, forKey: "inviteeAci")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupMemberJoinedUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupMemberJoinedUpdate : Hashable {
}
#endif

extension BackupProto.GroupMemberJoinedUpdate : Sendable {
}

extension BackupProto.GroupMemberJoinedUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupMemberJoinedUpdate"
    }

}

extension BackupProto.GroupMemberJoinedUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var newMemberAci: Foundation.Data = .init()

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: newMemberAci = try protoReader.decode(Foundation.Data.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.newMemberAci = newMemberAci
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.newMemberAci)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupMemberJoinedUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.newMemberAci = try container.decode(stringEncoded: Foundation.Data.self, forKey: "newMemberAci")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.newMemberAci.isEmpty {
            try container.encode(stringEncoded: self.newMemberAci, forKey: "newMemberAci")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupMemberAddedUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupMemberAddedUpdate : Hashable {
}
#endif

extension BackupProto.GroupMemberAddedUpdate : Sendable {
}

extension BackupProto.GroupMemberAddedUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupMemberAddedUpdate"
    }

}

extension BackupProto.GroupMemberAddedUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var updaterAci: Foundation.Data? = nil
        var newMemberAci: Foundation.Data = .init()
        var hadOpenInvitation: Bool = false
        var inviterAci: Foundation.Data? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: updaterAci = try protoReader.decode(Foundation.Data.self)
            case 2: newMemberAci = try protoReader.decode(Foundation.Data.self)
            case 3: hadOpenInvitation = try protoReader.decode(Bool.self)
            case 4: inviterAci = try protoReader.decode(Foundation.Data.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._updaterAci.wrappedValue = updaterAci
        self.newMemberAci = newMemberAci
        self.hadOpenInvitation = hadOpenInvitation
        self._inviterAci.wrappedValue = inviterAci
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.updaterAci)
        try protoWriter.encode(tag: 2, value: self.newMemberAci)
        try protoWriter.encode(tag: 3, value: self.hadOpenInvitation)
        try protoWriter.encode(tag: 4, value: self.inviterAci)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupMemberAddedUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._updaterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "updaterAci")
        self.newMemberAci = try container.decode(stringEncoded: Foundation.Data.self, forKey: "newMemberAci")
        self.hadOpenInvitation = try container.decode(Bool.self, forKey: "hadOpenInvitation")
        self._inviterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "inviterAci")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(stringEncoded: self.updaterAci, forKey: "updaterAci")
        if includeDefaults || !self.newMemberAci.isEmpty {
            try container.encode(stringEncoded: self.newMemberAci, forKey: "newMemberAci")
        }
        if includeDefaults || self.hadOpenInvitation != false {
            try container.encode(self.hadOpenInvitation, forKey: "hadOpenInvitation")
        }
        try container.encodeIfPresent(stringEncoded: self.inviterAci, forKey: "inviterAci")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupSelfInvitationRevokedUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupSelfInvitationRevokedUpdate : Hashable {
}
#endif

extension BackupProto.GroupSelfInvitationRevokedUpdate : Sendable {
}

extension BackupProto.GroupSelfInvitationRevokedUpdate : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.GroupSelfInvitationRevokedUpdate {
        BackupProto.GroupSelfInvitationRevokedUpdate()
    }
}

extension BackupProto.GroupSelfInvitationRevokedUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupSelfInvitationRevokedUpdate"
    }

}

extension BackupProto.GroupSelfInvitationRevokedUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var revokerAci: Foundation.Data? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: revokerAci = try protoReader.decode(Foundation.Data.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._revokerAci.wrappedValue = revokerAci
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.revokerAci)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupSelfInvitationRevokedUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._revokerAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "revokerAci")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(stringEncoded: self.revokerAci, forKey: "revokerAci")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupInvitationRevokedUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupInvitationRevokedUpdate : Hashable {
}
#endif

extension BackupProto.GroupInvitationRevokedUpdate : Sendable {
}

extension BackupProto.GroupInvitationRevokedUpdate : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.GroupInvitationRevokedUpdate {
        BackupProto.GroupInvitationRevokedUpdate()
    }
}

extension BackupProto.GroupInvitationRevokedUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupInvitationRevokedUpdate"
    }

}

extension BackupProto.GroupInvitationRevokedUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var updaterAci: Foundation.Data? = nil
        var invitees: [BackupProto.GroupInvitationRevokedUpdate.Invitee] = []

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: updaterAci = try protoReader.decode(Foundation.Data.self)
            case 2: try protoReader.decode(into: &invitees)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._updaterAci.wrappedValue = updaterAci
        self.invitees = invitees
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.updaterAci)
        try protoWriter.encode(tag: 2, value: self.invitees)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupInvitationRevokedUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._updaterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "updaterAci")
        self.invitees = try container.decodeProtoArray(BackupProto.GroupInvitationRevokedUpdate.Invitee.self, forKey: "invitees")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(stringEncoded: self.updaterAci, forKey: "updaterAci")
        if includeDefaults || !self.invitees.isEmpty {
            try container.encodeProtoArray(self.invitees, forKey: "invitees")
        }
    }

}
#endif

/**
 * Subtypes within BackupProto.GroupInvitationRevokedUpdate
 */
extension BackupProto.GroupInvitationRevokedUpdate {

    public struct Invitee {

        @ProtoDefaulted
        public var inviterAci: Foundation.Data?
        /**
         * Prefer to use aci over pni. No need to set
         * pni if aci is set. Both can be missing.
         */
        @ProtoDefaulted
        public var inviteeAci: Foundation.Data?
        @ProtoDefaulted
        public var inviteePni: Foundation.Data?
        public var unknownFields: UnknownFields = .init()

        public init(configure: (inout Self) -> Swift.Void = { _ in }) {
            configure(&self)
        }

    }

}

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupInvitationRevokedUpdate.Invitee : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupInvitationRevokedUpdate.Invitee : Hashable {
}
#endif

extension BackupProto.GroupInvitationRevokedUpdate.Invitee : Sendable {
}

extension BackupProto.GroupInvitationRevokedUpdate.Invitee : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.GroupInvitationRevokedUpdate.Invitee {
        BackupProto.GroupInvitationRevokedUpdate.Invitee()
    }
}

extension BackupProto.GroupInvitationRevokedUpdate.Invitee : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupInvitationRevokedUpdate.Invitee"
    }

}

extension BackupProto.GroupInvitationRevokedUpdate.Invitee : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var inviterAci: Foundation.Data? = nil
        var inviteeAci: Foundation.Data? = nil
        var inviteePni: Foundation.Data? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: inviterAci = try protoReader.decode(Foundation.Data.self)
            case 2: inviteeAci = try protoReader.decode(Foundation.Data.self)
            case 3: inviteePni = try protoReader.decode(Foundation.Data.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._inviterAci.wrappedValue = inviterAci
        self._inviteeAci.wrappedValue = inviteeAci
        self._inviteePni.wrappedValue = inviteePni
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.inviterAci)
        try protoWriter.encode(tag: 2, value: self.inviteeAci)
        try protoWriter.encode(tag: 3, value: self.inviteePni)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupInvitationRevokedUpdate.Invitee : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._inviterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "inviterAci")
        self._inviteeAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "inviteeAci")
        self._inviteePni.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "inviteePni")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(stringEncoded: self.inviterAci, forKey: "inviterAci")
        try container.encodeIfPresent(stringEncoded: self.inviteeAci, forKey: "inviteeAci")
        try container.encodeIfPresent(stringEncoded: self.inviteePni, forKey: "inviteePni")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupJoinRequestUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupJoinRequestUpdate : Hashable {
}
#endif

extension BackupProto.GroupJoinRequestUpdate : Sendable {
}

extension BackupProto.GroupJoinRequestUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupJoinRequestUpdate"
    }

}

extension BackupProto.GroupJoinRequestUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var requestorAci: Foundation.Data = .init()

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: requestorAci = try protoReader.decode(Foundation.Data.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.requestorAci = requestorAci
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.requestorAci)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupJoinRequestUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.requestorAci = try container.decode(stringEncoded: Foundation.Data.self, forKey: "requestorAci")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.requestorAci.isEmpty {
            try container.encode(stringEncoded: self.requestorAci, forKey: "requestorAci")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupJoinRequestApprovalUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupJoinRequestApprovalUpdate : Hashable {
}
#endif

extension BackupProto.GroupJoinRequestApprovalUpdate : Sendable {
}

extension BackupProto.GroupJoinRequestApprovalUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupJoinRequestApprovalUpdate"
    }

}

extension BackupProto.GroupJoinRequestApprovalUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var requestorAci: Foundation.Data = .init()
        var updaterAci: Foundation.Data? = nil
        var wasApproved: Bool = false

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: requestorAci = try protoReader.decode(Foundation.Data.self)
            case 2: updaterAci = try protoReader.decode(Foundation.Data.self)
            case 3: wasApproved = try protoReader.decode(Bool.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.requestorAci = requestorAci
        self._updaterAci.wrappedValue = updaterAci
        self.wasApproved = wasApproved
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.requestorAci)
        try protoWriter.encode(tag: 2, value: self.updaterAci)
        try protoWriter.encode(tag: 3, value: self.wasApproved)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupJoinRequestApprovalUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.requestorAci = try container.decode(stringEncoded: Foundation.Data.self, forKey: "requestorAci")
        self._updaterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "updaterAci")
        self.wasApproved = try container.decode(Bool.self, forKey: "wasApproved")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.requestorAci.isEmpty {
            try container.encode(stringEncoded: self.requestorAci, forKey: "requestorAci")
        }
        try container.encodeIfPresent(stringEncoded: self.updaterAci, forKey: "updaterAci")
        if includeDefaults || self.wasApproved != false {
            try container.encode(self.wasApproved, forKey: "wasApproved")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupJoinRequestCanceledUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupJoinRequestCanceledUpdate : Hashable {
}
#endif

extension BackupProto.GroupJoinRequestCanceledUpdate : Sendable {
}

extension BackupProto.GroupJoinRequestCanceledUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupJoinRequestCanceledUpdate"
    }

}

extension BackupProto.GroupJoinRequestCanceledUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var requestorAci: Foundation.Data = .init()

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: requestorAci = try protoReader.decode(Foundation.Data.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.requestorAci = requestorAci
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.requestorAci)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupJoinRequestCanceledUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.requestorAci = try container.decode(stringEncoded: Foundation.Data.self, forKey: "requestorAci")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.requestorAci.isEmpty {
            try container.encode(stringEncoded: self.requestorAci, forKey: "requestorAci")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupSequenceOfRequestsAndCancelsUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupSequenceOfRequestsAndCancelsUpdate : Hashable {
}
#endif

extension BackupProto.GroupSequenceOfRequestsAndCancelsUpdate : Sendable {
}

extension BackupProto.GroupSequenceOfRequestsAndCancelsUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupSequenceOfRequestsAndCancelsUpdate"
    }

}

extension BackupProto.GroupSequenceOfRequestsAndCancelsUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var requestorAci: Foundation.Data = .init()
        var count: UInt32 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: requestorAci = try protoReader.decode(Foundation.Data.self)
            case 2: count = try protoReader.decode(UInt32.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.requestorAci = requestorAci
        self.count = count
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.requestorAci)
        try protoWriter.encode(tag: 2, value: self.count)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupSequenceOfRequestsAndCancelsUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.requestorAci = try container.decode(stringEncoded: Foundation.Data.self, forKey: "requestorAci")
        self.count = try container.decode(UInt32.self, forKey: "count")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.requestorAci.isEmpty {
            try container.encode(stringEncoded: self.requestorAci, forKey: "requestorAci")
        }
        if includeDefaults || self.count != 0 {
            try container.encode(self.count, forKey: "count")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupInviteLinkResetUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupInviteLinkResetUpdate : Hashable {
}
#endif

extension BackupProto.GroupInviteLinkResetUpdate : Sendable {
}

extension BackupProto.GroupInviteLinkResetUpdate : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.GroupInviteLinkResetUpdate {
        BackupProto.GroupInviteLinkResetUpdate()
    }
}

extension BackupProto.GroupInviteLinkResetUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupInviteLinkResetUpdate"
    }

}

extension BackupProto.GroupInviteLinkResetUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var updaterAci: Foundation.Data? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: updaterAci = try protoReader.decode(Foundation.Data.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._updaterAci.wrappedValue = updaterAci
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.updaterAci)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupInviteLinkResetUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._updaterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "updaterAci")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(stringEncoded: self.updaterAci, forKey: "updaterAci")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupInviteLinkEnabledUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupInviteLinkEnabledUpdate : Hashable {
}
#endif

extension BackupProto.GroupInviteLinkEnabledUpdate : Sendable {
}

extension BackupProto.GroupInviteLinkEnabledUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupInviteLinkEnabledUpdate"
    }

}

extension BackupProto.GroupInviteLinkEnabledUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var updaterAci: Foundation.Data? = nil
        var linkRequiresAdminApproval: Bool = false

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: updaterAci = try protoReader.decode(Foundation.Data.self)
            case 2: linkRequiresAdminApproval = try protoReader.decode(Bool.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._updaterAci.wrappedValue = updaterAci
        self.linkRequiresAdminApproval = linkRequiresAdminApproval
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.updaterAci)
        try protoWriter.encode(tag: 2, value: self.linkRequiresAdminApproval)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupInviteLinkEnabledUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._updaterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "updaterAci")
        self.linkRequiresAdminApproval = try container.decode(Bool.self, forKey: "linkRequiresAdminApproval")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(stringEncoded: self.updaterAci, forKey: "updaterAci")
        if includeDefaults || self.linkRequiresAdminApproval != false {
            try container.encode(self.linkRequiresAdminApproval, forKey: "linkRequiresAdminApproval")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupInviteLinkAdminApprovalUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupInviteLinkAdminApprovalUpdate : Hashable {
}
#endif

extension BackupProto.GroupInviteLinkAdminApprovalUpdate : Sendable {
}

extension BackupProto.GroupInviteLinkAdminApprovalUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupInviteLinkAdminApprovalUpdate"
    }

}

extension BackupProto.GroupInviteLinkAdminApprovalUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var updaterAci: Foundation.Data? = nil
        var linkRequiresAdminApproval: Bool = false

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: updaterAci = try protoReader.decode(Foundation.Data.self)
            case 2: linkRequiresAdminApproval = try protoReader.decode(Bool.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._updaterAci.wrappedValue = updaterAci
        self.linkRequiresAdminApproval = linkRequiresAdminApproval
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.updaterAci)
        try protoWriter.encode(tag: 2, value: self.linkRequiresAdminApproval)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupInviteLinkAdminApprovalUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._updaterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "updaterAci")
        self.linkRequiresAdminApproval = try container.decode(Bool.self, forKey: "linkRequiresAdminApproval")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(stringEncoded: self.updaterAci, forKey: "updaterAci")
        if includeDefaults || self.linkRequiresAdminApproval != false {
            try container.encode(self.linkRequiresAdminApproval, forKey: "linkRequiresAdminApproval")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupInviteLinkDisabledUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupInviteLinkDisabledUpdate : Hashable {
}
#endif

extension BackupProto.GroupInviteLinkDisabledUpdate : Sendable {
}

extension BackupProto.GroupInviteLinkDisabledUpdate : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.GroupInviteLinkDisabledUpdate {
        BackupProto.GroupInviteLinkDisabledUpdate()
    }
}

extension BackupProto.GroupInviteLinkDisabledUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupInviteLinkDisabledUpdate"
    }

}

extension BackupProto.GroupInviteLinkDisabledUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var updaterAci: Foundation.Data? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: updaterAci = try protoReader.decode(Foundation.Data.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._updaterAci.wrappedValue = updaterAci
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.updaterAci)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupInviteLinkDisabledUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._updaterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "updaterAci")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)

        try container.encodeIfPresent(stringEncoded: self.updaterAci, forKey: "updaterAci")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupMemberJoinedByLinkUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupMemberJoinedByLinkUpdate : Hashable {
}
#endif

extension BackupProto.GroupMemberJoinedByLinkUpdate : Sendable {
}

extension BackupProto.GroupMemberJoinedByLinkUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupMemberJoinedByLinkUpdate"
    }

}

extension BackupProto.GroupMemberJoinedByLinkUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var newMemberAci: Foundation.Data = .init()

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: newMemberAci = try protoReader.decode(Foundation.Data.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.newMemberAci = newMemberAci
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.newMemberAci)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupMemberJoinedByLinkUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.newMemberAci = try container.decode(stringEncoded: Foundation.Data.self, forKey: "newMemberAci")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.newMemberAci.isEmpty {
            try container.encode(stringEncoded: self.newMemberAci, forKey: "newMemberAci")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupV2MigrationUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupV2MigrationUpdate : Hashable {
}
#endif

extension BackupProto.GroupV2MigrationUpdate : Sendable {
}

extension BackupProto.GroupV2MigrationUpdate : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.GroupV2MigrationUpdate {
        BackupProto.GroupV2MigrationUpdate()
    }
}

extension BackupProto.GroupV2MigrationUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupV2MigrationUpdate"
    }

}

extension BackupProto.GroupV2MigrationUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupV2MigrationUpdate : Codable {

    public enum CodingKeys : CodingKey {
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupV2MigrationSelfInvitedUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupV2MigrationSelfInvitedUpdate : Hashable {
}
#endif

extension BackupProto.GroupV2MigrationSelfInvitedUpdate : Sendable {
}

extension BackupProto.GroupV2MigrationSelfInvitedUpdate : ProtoDefaultedValue {

    public static var defaultedValue: BackupProto.GroupV2MigrationSelfInvitedUpdate {
        BackupProto.GroupV2MigrationSelfInvitedUpdate()
    }
}

extension BackupProto.GroupV2MigrationSelfInvitedUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupV2MigrationSelfInvitedUpdate"
    }

}

extension BackupProto.GroupV2MigrationSelfInvitedUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupV2MigrationSelfInvitedUpdate : Codable {

    public enum CodingKeys : CodingKey {
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupV2MigrationInvitedMembersUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupV2MigrationInvitedMembersUpdate : Hashable {
}
#endif

extension BackupProto.GroupV2MigrationInvitedMembersUpdate : Sendable {
}

extension BackupProto.GroupV2MigrationInvitedMembersUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupV2MigrationInvitedMembersUpdate"
    }

}

extension BackupProto.GroupV2MigrationInvitedMembersUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var invitedMembersCount: UInt32 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: invitedMembersCount = try protoReader.decode(UInt32.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.invitedMembersCount = invitedMembersCount
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.invitedMembersCount)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupV2MigrationInvitedMembersUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.invitedMembersCount = try container.decode(UInt32.self, forKey: "invitedMembersCount")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || self.invitedMembersCount != 0 {
            try container.encode(self.invitedMembersCount, forKey: "invitedMembersCount")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupV2MigrationDroppedMembersUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupV2MigrationDroppedMembersUpdate : Hashable {
}
#endif

extension BackupProto.GroupV2MigrationDroppedMembersUpdate : Sendable {
}

extension BackupProto.GroupV2MigrationDroppedMembersUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupV2MigrationDroppedMembersUpdate"
    }

}

extension BackupProto.GroupV2MigrationDroppedMembersUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var droppedMembersCount: UInt32 = 0

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: droppedMembersCount = try protoReader.decode(UInt32.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.droppedMembersCount = droppedMembersCount
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.droppedMembersCount)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupV2MigrationDroppedMembersUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.droppedMembersCount = try container.decode(UInt32.self, forKey: "droppedMembersCount")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || self.droppedMembersCount != 0 {
            try container.encode(self.droppedMembersCount, forKey: "droppedMembersCount")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.GroupExpirationTimerUpdate : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.GroupExpirationTimerUpdate : Hashable {
}
#endif

extension BackupProto.GroupExpirationTimerUpdate : Sendable {
}

extension BackupProto.GroupExpirationTimerUpdate : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.GroupExpirationTimerUpdate"
    }

}

extension BackupProto.GroupExpirationTimerUpdate : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var expiresInMs: UInt32 = 0
        var updaterAci: Foundation.Data? = nil

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: expiresInMs = try protoReader.decode(UInt32.self)
            case 2: updaterAci = try protoReader.decode(Foundation.Data.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.expiresInMs = expiresInMs
        self._updaterAci.wrappedValue = updaterAci
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.expiresInMs)
        try protoWriter.encode(tag: 2, value: self.updaterAci)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.GroupExpirationTimerUpdate : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.expiresInMs = try container.decode(UInt32.self, forKey: "expiresInMs")
        self._updaterAci.wrappedValue = try container.decodeIfPresent(stringEncoded: Foundation.Data.self, forKey: "updaterAci")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || self.expiresInMs != 0 {
            try container.encode(self.expiresInMs, forKey: "expiresInMs")
        }
        try container.encodeIfPresent(stringEncoded: self.updaterAci, forKey: "updaterAci")
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.StickerPack : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.StickerPack : Hashable {
}
#endif

extension BackupProto.StickerPack : Sendable {
}

extension BackupProto.StickerPack : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.StickerPack"
    }

}

extension BackupProto.StickerPack : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var id: Foundation.Data = .init()
        var key: Foundation.Data = .init()
        var title: String = ""
        var author: String = ""
        var stickers: [BackupProto.StickerPackSticker] = []

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: id = try protoReader.decode(Foundation.Data.self)
            case 2: key = try protoReader.decode(Foundation.Data.self)
            case 3: title = try protoReader.decode(String.self)
            case 4: author = try protoReader.decode(String.self)
            case 5: try protoReader.decode(into: &stickers)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self.id = id
        self.key = key
        self.title = title
        self.author = author
        self.stickers = stickers
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.id)
        try protoWriter.encode(tag: 2, value: self.key)
        try protoWriter.encode(tag: 3, value: self.title)
        try protoWriter.encode(tag: 4, value: self.author)
        try protoWriter.encode(tag: 5, value: self.stickers)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.StickerPack : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self.id = try container.decode(stringEncoded: Foundation.Data.self, forKey: "id")
        self.key = try container.decode(stringEncoded: Foundation.Data.self, forKey: "key")
        self.title = try container.decode(String.self, forKey: "title")
        self.author = try container.decode(String.self, forKey: "author")
        self.stickers = try container.decodeProtoArray(BackupProto.StickerPackSticker.self, forKey: "stickers")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        if includeDefaults || !self.id.isEmpty {
            try container.encode(stringEncoded: self.id, forKey: "id")
        }
        if includeDefaults || !self.key.isEmpty {
            try container.encode(stringEncoded: self.key, forKey: "key")
        }
        if includeDefaults || !self.title.isEmpty {
            try container.encode(self.title, forKey: "title")
        }
        if includeDefaults || !self.author.isEmpty {
            try container.encode(self.author, forKey: "author")
        }
        if includeDefaults || !self.stickers.isEmpty {
            try container.encodeProtoArray(self.stickers, forKey: "stickers")
        }
    }

}
#endif

#if !WIRE_REMOVE_EQUATABLE
extension BackupProto.StickerPackSticker : Equatable {
}
#endif

#if !WIRE_REMOVE_HASHABLE
extension BackupProto.StickerPackSticker : Hashable {
}
#endif

extension BackupProto.StickerPackSticker : Sendable {
}

extension BackupProto.StickerPackSticker : ProtoMessage {

    public static func protoMessageTypeURL() -> String {
        return "type.googleapis.com/BackupProto.BackupProto.StickerPackSticker"
    }

}

extension BackupProto.StickerPackSticker : Proto3Codable {

    public init(from protoReader: ProtoReader) throws {
        var data: BackupProto.FilePointer? = nil
        var emoji: String = ""

        let token = try protoReader.beginMessage()
        while let tag = try protoReader.nextTag(token: token) {
            switch tag {
            case 1: data = try protoReader.decode(BackupProto.FilePointer.self)
            case 2: emoji = try protoReader.decode(String.self)
            default: try protoReader.readUnknownField(tag: tag)
            }
        }
        self.unknownFields = try protoReader.endMessage(token: token)

        self._data.wrappedValue = data
        self.emoji = emoji
    }

    public func encode(to protoWriter: ProtoWriter) throws {
        try protoWriter.encode(tag: 1, value: self.data)
        try protoWriter.encode(tag: 2, value: self.emoji)
        try protoWriter.writeUnknownFields(unknownFields)
    }

}

#if !WIRE_REMOVE_CODABLE
extension BackupProto.StickerPackSticker : Codable {

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringLiteralCodingKeys.self)
        self._data.wrappedValue = try container.decodeIfPresent(BackupProto.FilePointer.self, forKey: "data")
        self.emoji = try container.decode(String.self, forKey: "emoji")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringLiteralCodingKeys.self)
        let includeDefaults = encoder.protoDefaultValuesEncodingStrategy == .include

        try container.encodeIfPresent(self.data, forKey: "data")
        if includeDefaults || !self.emoji.isEmpty {
            try container.encode(self.emoji, forKey: "emoji")
        }
    }

}
#endif
